
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <title>OKX Trading Dashboard</title>
    <style>
        body {
            background: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #64748b;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            position: relative;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: -1;
        }
        .container {
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(30px);
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.95), 0 0 40px rgba(30, 58, 138, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.03);
            padding: 30px;
            margin-top: 50px;
            border: 1px solid rgba(30, 41, 59, 0.6);
            animation: fadeInUp 0.8s ease-out;
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

                
        h2 {
            color: #64748b;
            text-align: center;
            margin-bottom: 30px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.9);
        }
        .form-group {
            margin-bottom: 20px;
        }
        .table {
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.8);
            background: rgba(15, 23, 42, 0.9);
        }
        .table thead th {
            background: linear-gradient(45deg, #0f172a, #1e293b);
            color: #475569;
            border: none;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.75rem;
            padding: 0.5rem 0.25rem;
            border-bottom: 2px solid #334155;
        }
        /* Debug CSS removed after verification */
        .table tbody td {
            padding: 0.5rem 0.25rem;
            font-size: 0.8rem;
            vertical-align: middle;
            color: #374151;
            border-bottom: 1px solid rgba(30, 41, 59, 0.5);
        }
        .table tbody tr:hover {
            background-color: rgba(30, 41, 59, 0.8);
            transform: scale(1.01);
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
        }
        .badge-buy {
            background: #48bb78;
        }
        .badge-sell {
            background: #f56565;
        }
        .loading {
            text-align: center;
            padding: 50px;
        }
        .spinner-border {
            color: #334155 !important;
            border-color: rgba(51, 65, 85, 0.3) !important;
            border-right-color: #64748b !important;
        }
        /* Override all Bootstrap white/light backgrounds */
        * {
            box-sizing: border-box;
        }
        html, body {
            background: #000000 !important;
        }
        .container, .card, .modal-content, .dropdown-menu, .popover, .tooltip {
            background: rgba(10, 10, 15, 0.95) !important;
            border-color: rgba(30, 41, 59, 0.6) !important;
        }
        .table {
            background: rgba(15, 23, 42, 0.9) !important;
        }
        .form-control, .form-select, input, select, textarea {
            background: rgba(15, 23, 42, 0.95) !important;
            border-color: rgba(30, 41, 59, 0.8) !important;
            color: #475569 !important;
        }
        .form-control:focus, .form-select:focus {
            background: rgba(30, 41, 59, 0.98) !important;
            border-color: #334155 !important;
            color: #64748b !important;
        }
        .btn, .button {
            background: rgba(30, 41, 59, 0.9) !important;
            border-color: rgba(51, 65, 85, 0.8) !important;
            color: #64748b !important;
        }
        .btn:hover, .button:hover {
            background: rgba(51, 65, 85, 0.95) !important;
            color: #94a3b8 !important;
        }
        /* Ensure no white backgrounds anywhere */
        .bg-white, .bg-light {
            background: #000000 !important;
        }
        .text-white {
            color: #64748b !important;
        }
        .border-white, .border-light {
            border-color: rgba(30, 41, 59, 0.6) !important;
        }
        /* Override any potential Bootstrap defaults */
        .navbar, .navbar-brand, .navbar-nav .nav-link {
            background: rgba(10, 10, 15, 0.98) !important;
            color: #475569 !important;
        }
        .alert, .badge, .list-group-item {
            background: rgba(15, 23, 42, 0.9) !important;
            color: #64748b !important;
            border-color: rgba(30, 41, 59, 0.6) !important;
        }
        /* Final comprehensive override for any remaining white elements */
        * {
            border-color: rgba(30, 41, 59, 0.6) !important;
        }
        body * {
            background-color: transparent !important;
        }
        .container, .table, .form-control, .form-select, .nav-tabs, .tab-content {
            background-color: rgba(10, 10, 15, 0.95) !important;
        }
        .durability-excellent {
            color: #00ff88 !important;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 136, 1), 0 0 16px rgba(0, 255, 136, 0.5);
        }
        .durability-good {
            color: #ffd700 !important;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 215, 0, 1), 0 0 16px rgba(255, 215, 0, 0.5);
        }
        .durability-poor {
            color: #ff4757 !important;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 71, 87, 1), 0 0 16px rgba(255, 71, 87, 0.5);
        }
        .durability-neutral {
            color: #374151 !important;
        }
        /* Recommendation styling */
        .recommendation-buy {
            color: #00ff88 !important;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0, 255, 136, 0.6);
        }
        .recommendation-sell {
            color: #ff4757 !important;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(255, 71, 87, 0.6);
        }
        .recommendation-hold {
            color: #ffd700 !important;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.6);
        }
        /* Dark theme form controls */
        .form-control, .form-select {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(30, 41, 59, 0.8);
            color: #475569;
        }
        .form-control:focus, .form-select:focus {
            background: rgba(30, 41, 59, 0.98);
            border-color: #334155;
            color: #64748b;
            box-shadow: 0 0 0 0.2rem rgba(30, 41, 59, 0.8);
        }
        .form-control::placeholder {
            color: #1f2937;
        }
        /* Dark theme tabs */
        .nav-tabs {
            border-bottom: 1px solid rgba(30, 41, 59, 0.8);
        }
        .nav-tabs .nav-link {
            color: #374151;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
        }
        .nav-tabs .nav-link:hover {
            color: #475569;
            border-bottom-color: rgba(30, 41, 59, 0.9);
        }
        .nav-tabs .nav-link.active {
            color: #64748b;
            background: rgba(15, 23, 42, 0.9);
            border-bottom-color: #334155;
        }
        /* Dark theme labels */
        .form-label {
            color: #475569;
            font-weight: 500;
        }
        /* Disable movement/scale on hover for the summary table rows so they are easy to click */
        #summaryBody tr:hover {
            transform: none !important;
            transition: background-color 0.12s ease !important;
            box-shadow: none !important;
        }
        /* Force pointer events for summary table and ensure rows are above possible overlays */
        #summaryBody, #summaryBody * {
            pointer-events: auto !important;
        }
        #summaryBody tr {
            position: relative;
            z-index: 2;
        }
    </style>
</head>

<body>
    <div class="container">
        <h2>ğŸš€ OKX Trading Dashboard</h2>
        <div class="alert alert-success alert-dismissible fade show" role="alert">
            <strong>ğŸ†• Fitur Baru!</strong> Volume Ratio % sekarang tersedia! Coba sorting by "ğŸ“Š Vol Ratio % (2h)" untuk melihat rasio Buy vs Sell dalam skala persentase.
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>

        <div class="row mb-4">
            <div class="col-md-4">
                <label class="form-label">ğŸ” Filter by Coin (per-tab)</label>
                <div id="filterContainer">
                    <input type="text" class="form-control filter-input" id="coinFilter_summary" placeholder="e.g., BTC, ETH">
                    <input type="text" class="form-control filter-input d-none" id="coinFilter_volume" placeholder="e.g., BTC, ETH">
                    <input type="text" class="form-control filter-input d-none" id="coinFilter_volDur" placeholder="e.g., BTC, ETH">
                    <input type="text" class="form-control filter-input d-none" id="coinFilter_spikes" placeholder="e.g., BTC, ETH">
                    <input type="text" class="form-control filter-input d-none" id="coinFilter_recs" placeholder="e.g., BTC, ETH">
                    <input type="text" class="form-control filter-input d-none" id="coinFilter_alerts" placeholder="e.g., BTC, ETH">
                </div>
            </div>
            <div class="col-md-4">
                <label for="limitInput" class="form-label">ğŸ“Š Limit Rows</label>
                <input type="number" class="form-control" id="limitInput" placeholder="Enter row limit" min="1" value="5">
            </div>
            <div class="col-md-4 d-flex align-items-end">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="persistHistoryToggle" checked>
                    <label class="form-check-label" for="persistHistoryToggle">ğŸ’¾ Persist History (LocalStorage)</label>
                </div>
            </div>
            <div class="col-md-4 d-flex align-items-end">
                <div>
                    <small class="text-muted">ğŸ”” Alerts configurable in the <strong>Alerts</strong> tab.</small>
                </div>
            </div>
            <div class="col-md-4">
                <label for="sortBy" class="form-label">ğŸ“Š Sort By <span class="badge bg-success">NEW: Vol Ratio %</span></label>
                <div class="form-text small text-muted">Note: feed no longer provides separate per-trade counts â€” "Activity" sorts use volume as a proxy.</div>
                <select class="form-select" id="sortBy">
                    <optgroup label="ğŸ“ˆ Durability">
                        <option value="vol_dur_2h">% Vol Durability (2h)</option>
                        <option value="activity_dur_2h">% Activity Durability (2h, vol proxy)</option>
                    </optgroup>
                    <optgroup label="ğŸ’° Price & Change">
                        <option value="change">% Change</option>
                        <option value="price">Price</option>
                        <option value="price_position" selected>Price Position (0-100)</option>
                        <option value="recommendation">Recommendation Score</option>
                    </optgroup>

                    
                    <optgroup label="ğŸ’¥ Volume (1m)">
                        <option value="vol_buy_1m">Vol Buy (1m)</option>
                        <option value="vol_sell_1m">Vol Sell (1m)</option>
                        <option value="vol_total_1m">Vol Total (1m)</option>
                        <option value="avg_vol_buy_1m">Avg Vol Buy (1m)</option>
                        <option value="avg_vol_sell_1m">Avg Vol Sell (1m)</option>
                    </optgroup>

                    <optgroup label="ğŸ’¹ Volume (5m)">
                        <option value="vol_buy_5m">Vol Buy (5m)</option>
                        <option value="vol_sell_5m">Vol Sell (5m)</option>
                        <option value="vol_total_5m">Vol Total (5m)</option>
                        <option value="avg_vol_buy_5m">Avg Vol Buy (5m)</option>
                        <option value="avg_vol_sell_5m">Avg Vol Sell (5m)</option>
                    </optgroup>
 
                    <optgroup label="ğŸ’¹ Volume (10m)">
                        <option value="vol_buy_10m">Vol Buy (10m)</option>
                        <option value="vol_sell_10m">Vol Sell (10m)</option>
                        <option value="vol_total_10m">Vol Total (10m)</option>
                        <option value="avg_vol_buy_10m">Avg Vol Buy (10m)</option>
                        <option value="avg_vol_sell_10m">Avg Vol Sell (10m)</option>
                    </optgroup>
  
                    
                    <optgroup label="ğŸ’¹ Volume (15m)">
                        <option value="vol_buy_15m">Vol Buy (15m)</option>
                        <option value="vol_sell_15m">Vol Sell (15m)</option>
                        <option value="vol_total_15m">Vol Total (15m)</option>
                        <option value="avg_vol_buy_15m">Avg Vol Buy (15m)</option>
                        <option value="avg_vol_sell_15m">Avg Vol Sell (15m)</option>
                    </optgroup>
 
                    
                    <optgroup label="ğŸ’¹ Volume (20m)">
                        <option value="vol_buy_20m">Vol Buy (20m)</option>
                        <option value="vol_sell_20m">Vol Sell (20m)</option>
                        <option value="vol_total_20m">Vol Total (20m)</option>
                        <option value="avg_vol_buy_20m">Avg Vol Buy (20m)</option>
                        <option value="avg_vol_sell_20m">Avg Vol Sell (20m)</option>
                    </optgroup>
          
                    
                    <optgroup label="ğŸ’° Volume (30m)">
                        <option value="vol_buy_30m">Vol Buy (30m)</option>
                        <option value="vol_sell_30m">Vol Sell (30m)</option>
                        <option value="vol_total_30m">Vol Total (30m)</option>
                        <option value="avg_vol_buy_30m">Avg Vol Buy (30m)</option>
                        <option value="avg_vol_sell_30m">Avg Vol Sell (30m)</option>
                    </optgroup>
          
                    
                    <optgroup label="ğŸ“Š Volume (1h)">
                        <option value="vol_buy_1h">Vol Buy (1h)</option>
                        <option value="vol_sell_1h">Vol Sell (1h)</option>
                        <option value="vol_total_1h">Vol Total (1h)</option>
                        <option value="avg_vol_buy_1h">Avg Vol Buy (1h)</option>
                        <option value="avg_vol_sell_1h">Avg Vol Sell (1h)</option>
                    </optgroup>

                    
                    <optgroup label="ğŸ“ˆ Volume (2h)">
                        <option value="vol_buy_2h">Vol Buy (2h)</option>
                        <option value="vol_sell_2h">Vol Sell (2h)</option>
                        <option value="vol_total_2h">Vol Total (2h)</option>
                        <option value="vol_ratio_2h" title="Volume Buy vs Sell Ratio in percentage (25% weight in recommendation)">ğŸ“Š Vol Ratio % (2h) - BUY/SELL Pressure â­</option>
                        <option value="avg_vol_buy_2h">Avg Vol Buy (2h)</option>
                        <option value="avg_vol_sell_2h">Avg Vol Sell (2h)</option>
                    </optgroup>
                    <optgroup label="ğŸ“Š Sum Durability">
                        <option value="sum_min_1_buy">Sum Min 1 Buy</option>
                        <option value="sum_min_5_buy">Sum Min 5 Buy</option>
                        <option value="sum_min_10_buy">Sum Min 10 Buy</option>
                        <option value="sum_min_15_buy">Sum Min 15 Buy</option>
                        <option value="sum_min_20_buy">Sum Min 20 Buy</option>
                        <option value="sum_min_30_buy">Sum Min 30 Buy</option>
                        <option value="sum_min_60_buy">Sum Min 60 Buy</option>
                        <option value="sum_min_120_buy">Sum Min 120 Buy</option>
                        <option value="sum_overall_buy">Sum Overall Buy</option>
                    </optgroup>
                    <option value="risk_score">âš–ï¸ Risk Score</option>
                    <optgroup label="ğŸ’° Volume Durability">
                        <option value="vol_dur_1m">% Vol Dur 1m</option>
                        <option value="vol_dur_5m">% Vol Dur 5m</option>
                        <option value="vol_dur_10m">% Vol Dur 10m</option>
                        <option value="vol_dur_15m">% Vol Dur 15m</option>
                        <option value="vol_dur_20m">% Vol Dur 20m</option>
                        <option value="vol_dur_30m">% Vol Dur 30m</option>
                        <option value="vol_dur_60m">% Vol Dur 60m</option>
                        <option value="vol_dur_120m">% Vol Dur 120m</option>
                        <option value="vol_dur_overall">% Vol Dur Overall</option>
                    </optgroup>
                    <optgroup label="ğŸ“ˆ Change Variations">
                        <option disabled class="text-muted">Detailed change metrics not available from feed</option>
                    </optgroup>
                    <optgroup label="â° Update Times">
                        <option value="update_activity">Update Time Activity</option>
                        <option value="update_sum">Update Time Sum</option>
                        <option value="update_general">Update Time General</option>
                    </optgroup>
                    <optgroup label="ğŸ’µ Total Volumes">
                        <option value="total_vol_fiat">Total Vol Fiat</option>
                        <option value="total_vol">Total Volume</option>
                    </optgroup>
                    <optgroup label="âš¡ Delay">
                        <option value="delay_ms">Delay MS</option>
                    </optgroup>
                    <optgroup label="ğŸŒŸ Overall (24h)">
                        <option value="activity_dur_24h">% Activity Durability (24h, vol proxy)</option>
                        <option value="vol_dur_24h">% Vol Durability (24h)</option>
                        <option value="vol_buy_24h">Vol Buy (24h)</option>
                        <option value="vol_sell_24h">Vol Sell (24h)</option>
                        <option value="vol_total_24h">Vol Total (24h)</option>
                    </optgroup>
                </select>
            </div>
            <div class="col-md-4">
                <label class="form-label">ğŸ“ˆ Sort Order</label>
                <div id="sortOrder" class="d-flex gap-2 align-items-center">
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="sortOrderRad" id="sortOrder_desc" value="desc" checked>
                        <label class="form-check-label small" for="sortOrder_desc">Descending â¬‡ï¸</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="sortOrderRad" id="sortOrder_asc" value="asc">
                        <label class="form-check-label small" for="sortOrder_asc">Ascending â¬†ï¸</label>
                    </div>
                </div>
            </div>
        </div>

        <div id="loading" class="loading">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p>Connecting to WebSocket...</p>
        </div>

        <ul class="nav nav-tabs" id="dataTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="summary-tab" data-bs-toggle="tab" data-bs-target="#summary" type="button" role="tab">ğŸ“Š Summary</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="volume-tab" data-bs-toggle="tab" data-bs-target="#volume" type="button" role="tab">ğŸ“Š Volume</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="volratio-tab" data-bs-toggle="tab" data-bs-target="#volRatio" type="button" role="tab">ğŸ“ˆ Vol Ratio</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="vol-dur-tab" data-bs-toggle="tab" data-bs-target="#volDur" type="button" role="tab">ğŸ“ˆ Vol Dur</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="insight-tab" data-bs-toggle="tab" data-bs-target="#insight" type="button" role="tab">ğŸ” Insight</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="info-tab" data-bs-toggle="tab" data-bs-target="#info" type="button" role="tab">â„¹ï¸ Info</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="alerts-tab" data-bs-toggle="tab" data-bs-target="#alerts" type="button" role="tab">ğŸ”” Alerts</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="recs-tab" data-bs-toggle="tab" data-bs-target="#recommendations" type="button" role="tab">ğŸ§­ Recs</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="signal-tab" data-bs-toggle="tab" data-bs-target="#signalLab" type="button" role="tab">ğŸ§ª Signal Lab</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="backtest-tab" data-bs-toggle="tab" data-bs-target="#backtest" type="button" role="tab">ğŸ§® Backtest</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="risk-tab" data-bs-toggle="tab" data-bs-target="#risk" type="button" role="tab">âš ï¸ Risk</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="events-tab" data-bs-toggle="tab" data-bs-target="#events" type="button" role="tab">ğŸ“… Events</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="spike-tab" data-bs-toggle="tab" data-bs-target="#spikes" type="button" role="tab">âš¡ Spikes</button>
            </li>
        </ul>

        <div class="row mb-3">
            <div class="col-12">
                <div class="d-flex justify-content-center">
                    <button class="btn btn-outline-success me-2" onclick="quickSort('vol_ratio_2h')">
                        ğŸš€ Quick Sort: Vol Ratio %
                    </button>
                    <button class="btn btn-outline-info" onclick="showVolRatioInfo()">
                        ğŸ“š Learn About Vol Ratio %
                    </button>
                </div>
            </div>
        </div>

        

        <div class="tab-content mt-4" id="dataTabsContent">
            <div class="tab-pane fade show active" id="summary" role="tabpanel">
                <div class="table-responsive">
                    <table class="table table-striped" id="summaryTable">
                        <thead>
                            <tr>
                                <th>Coin</th>
                                <th>ğŸ’° Price</th>
                                <th>ğŸ“Š Change %</th>
                                <th>ğŸ“ Price Pos</th>
                                <th>ğŸ¯ Recommendation</th>
                                <th>âš–ï¸ Risk</th>
                                <th>ğŸ“Š Vol Ratio % (2h)</th>
                                <th>ğŸ“Š Vol Buy (2h)</th>
                                <th>ğŸ“Š Vol Sell (2h)</th>
                                <th>âš–ï¸ Vol Dur (2h)</th>
                                <th>ğŸ“Š Vol Buy (24h)</th>
                                <th>ğŸ“Š Vol Sell (24h)</th>
                                <th>â° Update</th>
                            </tr>
                        </thead>
                        <tbody id="summaryBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Activity tab removed: feed only provides volume-based metrics now -->

            <div class="tab-pane fade" id="volume" role="tabpanel">
                <div class="table-responsive">
                    <table class="table table-striped" id="volTable">
                        <thead>
                            <tr>
                                <th>Coin</th>
                                <th>ğŸ“Š Buy 1m</th>
                                <th>ğŸ“Š Sell 1m</th>
                                <th>ğŸ“Š Buy 5m</th>
                                <th>ğŸ“Š Sell 5m</th>
                                <th>ğŸ“Š Buy 10m</th>
                                <th>ğŸ“Š Sell 10m</th>
                                <th>ğŸ“Š Buy 15m</th>
                                <th>ğŸ“Š Sell 15m</th>
                                <th>ğŸ“Š Buy 20m</th>
                                <th>ğŸ“Š Sell 20m</th>
                                <th>ğŸ“Š Buy 30m</th>
                                <th>ğŸ“Š Sell 30m</th>
                                <th>ğŸ“Š Buy 60m</th>
                                <th>ğŸ“Š Sell 60m</th>
                                <th>ğŸ“Š Buy 120m</th>
                                <th>ğŸ“Š Sell 120m</th>
                                <th>ğŸ“Š Ratio %</th>
                                <th>ğŸ“Š Buy (24h)</th>
                                <th>ğŸ“Š Sell (24h)</th>
                                <th>ğŸ“Š Total (24h)</th>
                            </tr>
                        </thead>
                        <tbody id="volBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="tab-pane fade" id="volRatio" role="tabpanel">
                <div class="table-responsive">
                    <table class="table table-striped" id="volRatioTable">
                        <thead>
                            <tr>
                                <th>Coin</th>
                                <th>1m</th>
                                <th>5m</th>
                                <th>10m</th>
                                <th>15m</th>
                                <th>20m</th>
                                <th>30m</th>
                                <th>1h</th>
                                <th>2h</th>
                                <th>24h</th>
                                <th>Last Change %</th>
                            </tr>
                        </thead>
                        <tbody id="volRatioBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="tab-pane fade" id="volDur" role="tabpanel">
                <div class="table-responsive">
                    <table class="table table-striped" id="volDurTable">
                        <thead>
                            <tr>
                                <th>Coin</th>
                                <th>ğŸ“Š Change %</th>
                                <th>1m</th>
                                <th>5m</th>
                                <th>10m</th>
                                <th>15m</th>
                                <th>20m</th>
                                <th>30m</th>
                                <th>1h</th>
                                <th>24h</th>
                            </tr>
                        </thead>
                        <tbody id="volDurBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="tab-pane fade" id="insight" role="tabpanel">
                <div class="row">
                    <div class="col-12">
                        <div id="insightPane">
                            <h4 class="text-info">ğŸ” Insight</h4>
                            <div id="insightPaneBody" class="card bg-dark text-light p-3">
                                <p class="text-muted">Select a coin from the Summary tab to see detailed insights here.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="info" role="tabpanel">
                <div id="infoRuntime" class="mb-3"></div>
                <div class="card bg-dark text-light mb-3">
                    <div class="card-body">
                        <h5 class="text-info">âœ¨ Fitur Tersedia / Available Features</h5>
                        <ul class="small mb-2">
                            <li><strong>Live feed:</strong> WebSocket client + Redis bridge (subscribe â†’ wss) untuk data real-time.</li>
                            <li><strong>Summary:</strong> Tabel ringkasan per-coin, klik baris untuk membuka Insight.</li>
                            <li><strong>Recommendations (Recs):</strong> Per-timeframe (1m/5m/10m/30m/60m/120m/24h) dan opsi <em>All</em> (konsensus antar-timeframe).</li>
                            <li><strong>TP/SL Controls:</strong> Atur TP% min/max, SL% max, dan sensitivitas; opsi ATR-based TP/SL tersedia.</li>
                            <li><strong>Volume & Vol Dur:</strong> Lihat buy/sell volume multi-timeframe dan durability metrics.</li>
                            <li><strong>Spike Detection:</strong> Deteksi lonjakan volume vs rata-rata per-timeframe.</li>
                            <li><strong>Alerts:</strong> Banner alerts, webhook test, sound toggle, dan mode compact untuk membatasi tampilan.</li>
                            <li><strong>Insight Export:</strong> Export data coin ke JSON/CSV dari modal Insight.</li>
                            <li><strong>UI behavior:</strong> Debounced updates, delegated row clicks, and deterministic recommendations (sorting/preview do not mutate state).</li>
                            <li><strong>Local Dev:</strong> Docker Compose included â€” runs Redis + example services (bridge/publisher/aggregator/count/generateavg). GenerateAvg scheduled in compose for periodic averages.</li>
                        </ul>
                        <p class="small text-muted mb-0">Tip singkat: gunakan tab <strong>Recs</strong> untuk memilih timeframe lalu periksa Summary agar nilainya konsisten. Untuk reproducibility, consider moving heavy analytics server-side.</p>
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-6">
                        <h4 class="text-info mb-3">ğŸ“Š <strong>Summary Tab - Kolom Utama</strong></h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                    <div class="d-flex gap-2 mb-3 align-items-center">
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" id="compactAlertsToggle">
                                            <label class="form-check-label small" for="compactAlertsToggle">Compact banners (limit visible alerts)</label>
                                        </div>
                                        <div class="input-group input-group-sm" style="width:140px;">
                                            <span class="input-group-text">Max</span>
                                            <input type="number" id="maxAlertBanners" class="form-control" value="3" min="0">
                                        </div>
                                        <div>
                                            <button id="showHiddenAlertsBtn" class="btn btn-sm btn-outline-secondary">Show hidden alerts</button>
                                        </div>
                                    </div>
                                <h6 class="card-title text-warning">Coin</h6>
                                <p class="card-text small">Nama cryptocurrency (BTC, ETH, dll)</p>

                                <h6 class="card-title text-warning">ğŸ’° Price</h6>
                                <p class="card-text small">Harga terakhir dalam USD</p>

                                <h6 class="card-title text-warning">ğŸ“Š Change %</h6>
                                <p class="card-text small">Persentase perubahan harga dalam periode terakhir</p>

                                <h6 class="card-title text-warning">ğŸ“ Price Pos</h6>
                                <p class="card-text small">Posisi harga dalam range High-Low (0-100). 0 = di Low, 100 = di High</p>

                                <h6 class="card-title text-warning">ğŸ¯ Recommendation</h6>
                                <p class="card-text small">Rekomendasi BUY/SELL/HOLD berdasarkan algoritma AI dengan tingkat confidence</p>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-6">
                        <h4 class="text-info mb-3">âš–ï¸ <strong>Durability Metrics</strong></h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                <h6 class="card-title text-success">âš–ï¸ Activity Dur (2h, vol proxy)</h6>
                                <p class="card-text small">Activity Durability 2 jam - Konsistensi aktivitas trading (volume digunakan sebagai proxy untuk frekuensi)</p>

                                <h6 class="card-title text-success">âš–ï¸ Vol Dur (1m/5m/10m/15m/20m/30m/1h/24h)</h6>
                                <p class="card-text small">Volume Durability - Kekuatan volume pembelian dalam timeframe tertentu</p>

                                <div class="mt-2">
                                    <span class="badge bg-success me-1">67-100%</span><small>Excellent</small><br>
                                    <span class="badge bg-warning me-1">34-66%</span><small>Good</small><br>
                                    <span class="badge bg-danger me-1">0-33%</span><small>Poor</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-md-6">
                        <h4 class="text-info mb-3">ğŸ“Š <strong>Volume Tab</strong></h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                <h6 class="card-title text-info">ğŸ“Š Buy/Sell 1m, 5m, 10m, 60m, 120m</h6>
                                <p class="card-text small">Volume pembelian/penjualan dalam satuan coin</p>

                                <h6 class="card-title text-info">ğŸ“Š Total</h6>
                                <p class="card-text small">Total volume trading (Buy + Sell)</p>

                                <h6 class="card-title text-info">ğŸ’µ Avg Vol Buy/Sell</h6>
                                <p class="card-text small">Rata-rata volume trading per periode waktu</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-md-12">
                        <h4 class="text-info mb-3">ğŸ¯ <strong>Recommendation Algorithm</strong></h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-md-4">
                                        <h6 class="text-success">ğŸŸ¢ BUY (â‰¥60% confidence)</h6>
                                        <ul class="small">
                                            <li>Harga dekat level Low (Price Pos â‰¤33%)</li>
                                            <li>Momentum harga turun signifikan (<-5%)</li>
                                            <li>Volume Durability tinggi (â‰¥67%)</li>
                                            <li>Activity Durability tinggi (vol proxy) (â‰¥67%)</li>
                                            <li><strong>Volume Buy 2x > Volume Sell (ratio >2.0)</strong></li>
                                        </ul>
                                    </div>
                                    <div class="col-md-4">
                                        <h6 class="text-danger">ğŸ”´ SELL (â‰¥60% confidence)</h6>
                                        <ul class="small">
                                            <li>Harga dekat level High (Price Pos â‰¥67%)</li>
                                            <li>Momentum harga naik signifikan (>5%)</li>
                                            <li>Volume Durability rendah (â‰¤33%)</li>
                                            <li>Activity Durability rendah (vol proxy) (â‰¤33%)</li>
                                            <li><strong>Volume Sell 2x > Volume Buy (ratio <0.5)</strong></li>
                                        </ul>
                                    </div>
                                    <div class="col-md-4">
                                        <h6 class="text-warning">ğŸŸ¡ HOLD (<60% confidence)</h6>
                                        <ul class="small">
                                            <li>Kondisi pasar netral/mixed</li>
                                            <li>Tidak ada sinyal kuat BUY atau SELL</li>
                                            <li>Perlu monitoring lebih lanjut</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-12">
                        <h4 class="text-info mb-3">âš–ï¸ <strong>Faktor Rekomendasi & Bobot</strong></h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-md-6">
                                        <h6 class="text-primary">ğŸ“ Posisi Harga (25%)</h6>
                                        <p class="small mb-2">Posisi harga saat ini dalam range High-Low</p>

                                        <h6 class="text-primary">ğŸ“ˆ Momentum Harga (15%)</h6>
                                        <p class="small mb-2">Perubahan persentase harga terkini</p>

                                        <h6 class="text-primary">ğŸ’¹ Durabilitas Volume 2h (12%)</h6>
                                        <p class="small mb-2">Konsistensi volume beli dalam 2 jam</p>

                                        <h6 class="text-primary">ğŸ”„ Durabilitas Frekuensi 2h (12%)</h6>
                                        <p class="small mb-2">Konsistensi frekuensi transaksi beli</p>
                                    </div>
                                    <div class="col-md-6">
                                        <h6 class="text-success">ğŸ“Š Rasio Volume Buy/Sell (25%)</h6>
                                        <p class="small mb-2"><strong>FAKTOR PENTING:</strong> Perbandingan volume beli vs jual</p>

                                        <h6 class="text-primary">ğŸ“… Durabilitas 24h (8%)</h6>
                                        <p class="small mb-2">Konsistensi volume dalam 24 jam</p>

                                        <h6 class="text-primary">âš¡ Momentum vs Rata-rata (3%)</h6>
                                        <p class="small mb-2">Volume terkini vs rata-rata historis</p>

                                        <div class="alert alert-info small mt-3">
                                            <strong>ğŸ’¡ Update:</strong> Bobot Volume Ratio dinaikkan dari 10% ke 25% karena lebih mencerminkan tekanan beli/jual sesungguhnya
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-md-6">
                        <h4 class="text-info mb-3">ğŸ“Š <strong>Data Lainnya</strong></h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                <h6 class="card-title text-secondary">ğŸ’µ Total Vol</h6>
                                <p class="card-text small">Total volume dalam fiat currency</p>

                                <h6 class="card-title text-secondary">â° Update</h6>
                                <p class="card-text small">Waktu terakhir data diupdate</p>

                                <h6 class="card-title text-secondary">ğŸ“ˆ Activity Buy/Sell (2h, vol proxy)</h6>
                                <p class="card-text small">Aktivitas buy/sell dalam 2 jam terakhir (volume digunakan sebagai proxy untuk frekuensi)</p>

                                <h6 class="card-title text-secondary">ğŸ“Š Vol Buy/Sell (2h)</h6>
                                <p class="card-text small">Volume buy/sell dalam 2 jam terakhir</p>

                                <h6 id="volRatioSection" class="card-title text-success">ğŸ“Š Vol Ratio %</h6>
                                <div class="card-text small">
                                    <strong>Rasio Volume Buy vs Sell dalam skala 100%</strong><br>
                                    <strong>Formula:</strong> (Volume Buy Ã· Volume Sell) Ã— 100%<br><br>

                                    <strong>ğŸ“ˆ Interpretasi:</strong><br>
                                    â€¢ <strong>500%+</strong>: Ekstrem bullish - Buy volume 5x lebih besar<br>
                                    â€¢ <strong>200-500%</strong>: Sangat bullish - Buy volume 2-5x lebih besar<br>
                                    â€¢ <strong>150-200%</strong>: Bullish moderat - Buy volume 1.5-2x lebih besar<br>
                                    â€¢ <strong>80-150%</strong>: Sedikit bullish - Buy volume lebih dominan<br>
                                    â€¢ <strong>50-80%</strong>: Netral - Rasio seimbang<br>
                                    â€¢ <strong>20-50%</strong>: Bearish moderat - Sell volume lebih dominan<br>
                                    â€¢ <strong>0-20%</strong>: Sangat bearish - Sell volume mendominasi<br><br>

                                    <strong>ğŸ¯ Trading Signals:</strong><br>
                                    â€¢ <strong>ğŸŸ¢ >200%</strong>: Strong BUY signal - Institutional buying<br>
                                    â€¢ <strong>ğŸŸ¡ 50-200%</strong>: HOLD - Market balance<br>
                                    â€¢ <strong>ğŸ”´ <50%</strong>: Strong SELL signal - Distribution phase<br><br>

                                    <strong>âš ï¸ Special Cases:</strong><br>
                                    â€¢ <strong>999%</strong>: Only BUY volume (no SELL)<br>
                                    â€¢ <strong>0%</strong>: Only SELL volume (no BUY)<br>
                                    â€¢ <strong>100%</strong>: Perfect balance<br><br>

                                    <strong>ğŸ“Š Data Source:</strong> count_VOL_minute_120_buy vs count_VOL_minute_120_sell
                                </div>

                                <h6 class="card-title text-info mt-3">ğŸ“Š Vol Buy/Sell (24h)</h6>
                                <p class="card-text small"><strong>Volume buy/sell dalam 24 jam terakhir</strong><br>
                                Berguna untuk melihat tren jangka panjang dan perbandingan dengan volume 2 jam<br>
                                <strong>Data Source:</strong> count_VOL_minute_1440_buy vs count_VOL_minute_1440_sell</p>

                                <h6 class="card-title text-warning mt-3">ğŸ¯ Dampak pada Rekomendasi</h6>
                                <div class="card-text small">
                                    <strong>Volume Ratio mempengaruhi algoritma rekomendasi dengan bobot 25%:</strong><br>
                                    <strong>Menggunakan data 2 jam terakhir untuk sinyal real-time</strong><br><br>

                                    <strong>ğŸ“ˆ BUY Signals Enhanced:</strong><br>
                                    â€¢ Ratio >200% (+25 poin BUY)<br>
                                    â€¢ Ratio >150% (+15 poin BUY)<br><br>

                                    <strong>ğŸ“‰ SELL Signals Enhanced:</strong><br>
                                    â€¢ Ratio <50% (+25 poin SELL)<br>
                                    â€¢ Ratio <67% (+15 poin SELL)<br><br>

                                    <strong>ğŸ’¡ Mengapa 2 Jam?</strong><br>
                                    Volume 2 jam memberikan sinyal yang lebih timely dan relevant untuk trading HFT<br>
                                    Volume 24 jam lebih cocok untuk analisis tren jangka panjang<br><br>

                                    <strong>âš¡ Real-time Advantage:</strong><br>
                                    Volume ratio memberikan sinyal lebih awal daripada perubahan harga karena mencerminkan intent pasar sebelum harga bergerak signifikan.
                                </div>

                                <h6 class="card-title text-info mt-3">ğŸ“š Cara Menggunakan Vol Ratio %</h6>
                                <div class="card-text small">
                                    <strong>ğŸ”¥ Scalping Strategy:</strong><br>
                                    â€¢ Cari ratio >300% untuk entry BUY<br>
                                    â€¢ Exit ketika ratio turun ke <150%<br>
                                    â€¢ Stop loss jika ratio <50%<br><br>

                                    <strong>ğŸ“Š Swing Trading:</strong><br>
                                    â€¢ Monitor perubahan ratio harian<br>
                                    â€¢ Konfirmasi dengan durability metrics<br>
                                    â€¢ Gunakan sebagai filter untuk entry/exit<br><br>

                                    <strong>âš ï¸ Risk Management:</strong><br>
                                    â€¢ Jangan trading melawan ratio ekstrem<br>
                                    â€¢ Ratio >500% bisa berarti overbought<br>
                                    â€¢ Ratio <20% bisa berarti oversold<br><br>

                                    <strong>ğŸ”„ Market Context:</strong><br>
                                    â€¢ Bandingkan dengan rata-rata historis<br>
                                    â€¢ Perhatikan volume total bersamaan<br>
                                    â€¢ Kombinasikan dengan price action<br><br>

                                    <strong>ğŸ’¡ Pro Tips:</strong><br>
                                    â€¢ Ratio mendadak >400% = Institutional buying<br>
                                    â€¢ Ratio konsisten >200% = Strong uptrend<br>
                                    â€¢ Ratio turun ke <100% = Warning signal<br>
                                    â€¢ Ratio <30% = Potential reversal zone
                                </div>

                                <h6 class="card-title text-primary mt-3">ğŸ”— Hubungan dengan Indikator Lain</h6>
                                <div class="card-text small">
                                    <strong>ğŸ“ˆ Dengan Price Position:</strong><br>
                                    â€¢ Ratio >200% + Price Pos >67% = Overbought<br>
                                    â€¢ Ratio <50% + Price Pos <33% = Oversold<br>
                                    â€¢ Ratio >150% + Price Pos <50% = Accumulation<br><br>

                                    <strong>ğŸ’¹ Dengan Durability:</strong><br>
                                    â€¢ Ratio >200% + Durability >67% = Strong conviction<br>
                                    â€¢ Ratio >150% + Durability <33% = Weak momentum<br>
                                    â€¢ Ratio <50% + Durability >67% = Distribution<br><br>

                                    <strong>ğŸ“Š Dengan Volume Total:</strong><br>
                                    â€¢ High ratio + High volume = Institutional interest<br>
                                    â€¢ High ratio + Low volume = Retail buying<br>
                                    â€¢ Low ratio + High volume = Institutional selling<br><br>

                                    <strong>âš¡ Dengan Momentum:</strong><br>
                                    â€¢ Ratio >200% + Positive change = Bullish confirmation<br>
                                    â€¢ Ratio <50% + Negative change = Bearish confirmation<br>
                                    â€¢ Ratio neutral + High momentum = Short-term move<br><br>

                                    <strong>ğŸ¯ Best Combinations:</strong><br>
                                    â€¢ Ratio >200% + Durability >67% + Price Pos <50% = STRONG BUY<br>
                                    â€¢ Ratio <50% + Durability >67% + Price Pos >50% = STRONG SELL
                                </div>

                                <h6 class="card-title text-danger mt-3">ğŸ“– Studi Kasus Volume Ratio</h6>
                                <div class="card-text small">
                                    <strong>ğŸ“ˆ Kasus 1 - Pump Detection:</strong><br>
                                    Ratio tiba-tiba naik dari 80% ke 450% dalam 5 menit<br>
                                    Durability turun dari 75% ke 25%<br>
                                    <strong>Signal:</strong> Artificial pump - jangan ikut<br><br>

                                    <strong>ğŸ“‰ Kasus 2 - Institutional Accumulation:</strong><br>
                                    Ratio konsisten 180-220% selama 2 jam<br>
                                    Durability stabil di 70-80%<br>
                                    Volume total meningkat<br>
                                    <strong>Signal:</strong> Smart money buying - ikuti trend<br><br>

                                    <strong>âš¡ Kasus 3 - Reversal Signal:</strong><br>
                                    Ratio turun dari 250% ke 45% dalam 15 menit<br>
                                    Price position masih di 70%<br>
                                    <strong>Signal:</strong> Momentum shift - exit long positions<br><br>

                                    <strong>ğŸ”„ Kasus 4 - Sideways Market:</strong><br>
                                    Ratio berfluktuasi 90-110% selama berjam-jam<br>
                                    Durability rendah di semua timeframe<br>
                                    <strong>Signal:</strong> Consolidation - tunggu breakout<br><br>

                                    <strong>ğŸ’¥ Kasus 5 - Panic Selling:</strong><br>
                                    Ratio turun drastis ke 15% dalam waktu singkat<br>
                                    Durability melonjak ke 85%<br>
                                    <strong>Signal:</strong> Oversold condition - potential bounce<br><br>

                                    <strong>ğŸ¯ Lesson Learned:</strong><br>
                                    Volume ratio bukan indikator standalone. Selalu konfirmasi dengan durability, price position, dan volume total untuk sinyal yang lebih akurat.
                                </div>

                                <h6 class="card-title text-secondary mt-3">âš ï¸ Troubleshooting & Common Mistakes</h6>
                                <div class="card-text small">
                                    <strong>ğŸš« Jangan Salah Interpretasi:</strong><br>
                                    â€¢ Ratio 300% bukan berarti harga akan naik 3x<br>
                                    â€¢ Ratio ekstrem bisa berarti thin liquidity<br>
                                    â€¢ Ratio 100% bukan berarti market netral<br><br>

                                    <strong>ğŸ” False Signals:</strong><br>
                                    â€¢ Market maker manipulation<br>
                                    â€¢ Low volume periods<br>
                                    â€¢ News-driven spikes<br>
                                    â€¢ Coin listing effects<br><br>

                                    <strong>ğŸ“Š Validation Steps:</strong><br>
                                    1. Check volume total (minimal threshold)<br>
                                    2. Verify durability consistency<br>
                                    3. Confirm price position alignment<br>
                                    4. Look for multi-timeframe confirmation<br>
                                    5. Consider market context<br><br>

                                    <strong>â° Time-based Considerations:</strong><br>
                                    â€¢ Asian session: Lower volume, higher volatility<br>
                                    â€¢ US session: Higher volume, more reliable signals<br>
                                    â€¢ Weekend: Thin liquidity, unreliable ratios<br>
                                    â€¢ Major news: Extreme ratios, high risk<br><br>

                                    <strong>ğŸª Market Manipulation Signs:</strong><br>
                                    â€¢ Ratio changes >500% in <5 minutes<br>
                                    â€¢ Durability drops while ratio spikes<br>
                                    â€¢ Volume total doesn't support the ratio<br>
                                    â€¢ Opposite signals across timeframes
                                </div>

                                <h6 class="card-title text-light mt-3">ğŸ“ˆ Monitoring & Development Over Time</h6>
                                <div class="card-text small">
                                    <strong>ğŸ“Š Historical Baseline:</strong><br>
                                    â€¢ Track ratio selama 24-48 jam untuk baseline<br>
                                    â€¢ Identifikasi level support/resistance ratio<br>
                                    â€¢ Catat pola ratio pada timeframe berbeda<br><br>

                                    <strong>ğŸ”„ Ratio Evolution:</strong><br>
                                    â€¢ Monitor perubahan ratio per 5-15 menit<br>
                                    â€¢ Cari pola: rising/falling/consolidating<br>
                                    â€¢ Bandingkan dengan volume total trend<br><br>

                                    <strong>ğŸ¯ Alert Setup:</strong><br>
                                    â€¢ Alert ketika ratio >300% (strong buy)<br>
                                    â€¢ Alert ketika ratio <30% (strong sell)<br>
                                    â€¢ Alert ketika ratio crosses 100%<br><br>

                                    <strong>ğŸ“± Mobile Monitoring:</strong><br>
                                    â€¢ Focus pada ratio ekstrem (>250% atau <40%)<br>
                                    â€¢ Monitor 2-3 coin favorit saja<br>
                                    â€¢ Set notifikasi untuk sinyal penting<br><br>

                                    <strong>ğŸ§  Learning Process:</strong><br>
                                    â€¢ Backtest ratio signals pada historical data<br>
                                    â€¢ Catat hasil trading berdasarkan ratio<br>
                                    â€¢ Adjust threshold berdasarkan pengalaman<br>
                                    â€¢ Combine dengan indikator favorit Anda<br><br>

                                    <strong>ğŸš€ Advanced Usage:</strong><br>
                                    â€¢ Create ratio-based trading bots<br>
                                    â€¢ Develop ratio divergence strategies<br>
                                    â€¢ Use ratio for risk management<br>
                                    â€¢ Integrate dengan portfolio management
                                </div>

                                <div class="alert alert-success small mt-3">
                                    <strong>ğŸ’¡ Kesimpulan Volume Ratio %:</strong><br>
                                    Volume Ratio % adalah indikator fundamental yang menunjukkan arah aliran uang sesungguhnya di pasar crypto. Dengan bobot 25% dalam algoritma rekomendasi, metric ini menjadi salah satu faktor terpenting untuk mengidentifikasi tren pasar yang sebenarnya. Gunakan dengan bijak, selalu konfirmasi dengan indikator lain, dan ingat bahwa tidak ada indikator yang 100% akurat - risk management tetap yang utama!
                                </div>
                            </div>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-6">
                        <h4 class="text-info mb-3">ğŸ¨ <strong>Color Coding</strong></h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                <h6 class="card-title text-success">ğŸŸ¢ Green (Excellent)</h6>
                                <p class="card-text small">67-100% - Kondisi sangat baik</p>

                                <h6 class="card-title text-warning">ğŸŸ¡ Yellow (Good)</h6>
                                <p class="card-text small">34-66% - Kondisi cukup baik</p>

                                <h6 class="card-title text-danger">ğŸ”´ Red (Poor)</h6>
                                <p class="card-text small">0-33% - Kondisi kurang baik</p>

                                <h6 class="card-title text-success">ğŸŸ¢ BUY Recommendation</h6>
                                <p class="card-text small">Sinyal beli dengan confidence â‰¥60%</p>

                                <h6 class="card-title text-danger">ğŸ”´ SELL Recommendation</h6>
                                <p class="card-text small">Sinyal jual dengan confidence â‰¥60%</p>

                                <h6 class="card-title text-warning">ğŸŸ¡ HOLD Recommendation</h6>
                                <p class="card-text small">Tunggu dengan confidence <60%</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-md-12">
                        <div class="alert alert-info bg-dark text-light border-info">
                            <h5>ğŸ’¡ <strong>Tips Penggunaan:</strong></h5>
                            <ul class="mb-0">
                                <li><strong>Sorting:</strong> Klik header kolom untuk mengurutkan data</li>
                                <li><strong>Filtering:</strong> Gunakan search box untuk mencari coin tertentu</li>
                                <li><strong>Row Limit:</strong> Atur jumlah baris yang ditampilkan (default: 20)</li>
                                <li><strong>Real-time:</strong> Data diperbarui secara otomatis via WebSocket</li>
                                <li><strong>Recommendation:</strong> Gunakan sebagai panduan, bukan keputusan final</li>
                                <li><strong>Risk Management:</strong> Selalu gunakan stop-loss dan position sizing</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- Quick access: Open Recs tab directly under Tips Penggunaan -->
                <div class="row mt-2">
                    <div class="col-md-12 text-center">
                        <button id="openRecsBtn" class="btn btn-sm btn-outline-primary">Open Recs (Recommendations)</button>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="signalLab" role="tabpanel">
                <div class="card bg-dark text-light mb-3">
                    <div class="card-body">
                        <div class="row g-3 align-items-end">
                            <div class="col-md-4">
                                <label class="form-label small text-muted">Coin</label>
                                <select id="signalLabCoinSelect" class="form-select form-select-sm bg-dark text-light border-secondary"></select>
                            </div>
                            <div class="col-md-4">
                                <label class="form-label small text-muted">Timeframe</label>
                                <select id="signalLabTfSelect" class="form-select form-select-sm bg-dark text-light border-secondary">
                                    <option value="1m">1m</option>
                                    <option value="5m">5m</option>
                                    <option value="10m">10m</option>
                                    <option value="30m">30m</option>
                                    <option value="60m">60m</option>
                                    <option value="120m" selected>120m</option>
                                    <option value="24h">24h</option>
                                </select>
                            </div>
                            <div class="col-md-4">
                                <label class="form-label small text-muted">Status</label>
                                <div id="signalLabStatus" class="fw-bold">-</div>
                            </div>
                        </div>
                        <div id="signalLabPane" class="mt-3 small text-muted">
                            <p class="mb-0">Select a coin to see the multi-factor recommendation breakdown.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="backtest" role="tabpanel">
                <div class="card bg-dark text-light mb-3">
                    <div class="card-body">
                        <div class="row g-3 align-items-end">
                            <div class="col-md-4">
                                <label class="form-label small text-muted">Coin</label>
                                <select id="backtestCoinSelect" class="form-select form-select-sm bg-dark text-light border-secondary"></select>
                            </div>
                            <div class="col-md-4">
                                <label class="form-label small text-muted">Samples Used</label>
                                <div id="backtestSampleCount" class="fw-bold">-</div>
                            </div>
                            <div class="col-md-4 text-end">
                                <small class="text-muted">Based on recommendation log & local history</small>
                            </div>
                        </div>
                        <div id="backtestPane" class="mt-3 small text-muted">
                            <p class="mb-0">Waiting for recommendation historyâ€¦</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="risk" role="tabpanel">
                <div class="card bg-dark text-light mb-3">
                    <div class="card-body">
                        <div class="row g-3 align-items-end">
                            <div class="col-md-4">
                                <label class="form-label small text-muted">Coin</label>
                                <select id="riskCoinSelect" class="form-select form-select-sm bg-dark text-light border-secondary"></select>
                            </div>
                            <div class="col-md-4">
                                <label class="form-label small text-muted">Lookback</label>
                                <select id="riskLookbackSelect" class="form-select form-select-sm bg-dark text-light border-secondary">
                                    <option value="50">Last 50 pts</option>
                                    <option value="100" selected>Last 100 pts</option>
                                    <option value="200">Last 200 pts</option>
                                </select>
                            </div>
                            <div class="col-md-4 text-end">
                                <small class="text-muted">ATR, realized volatility, drawdowns</small>
                            </div>
                        </div>
                        <div id="riskPane" class="mt-3 small text-muted">
                            <p class="mb-0">Waiting for historyâ€¦</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="events" role="tabpanel">
                <div class="card bg-dark text-light mb-3">
                    <div class="card-body">
                        <h5 class="text-info">ğŸ“… Event Watch</h5>
                        <p class="small text-muted">Combines rule-based alerts, sharp insights, and spike detections logged locally.</p>
                        <div id="eventPane" class="mt-3 small text-muted">
                            <p class="mb-0">No events yet.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="alerts" role="tabpanel">
                <div class="row">
                    <div class="col-md-6">
                        <h4 class="text-info">ğŸ”” Alerts</h4>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body">
                                <div class="form-check form-switch mb-2">
                                    <input class="form-check-input" type="checkbox" id="enableAlertsToggle">
                                    <label class="form-check-label" for="enableAlertsToggle">ğŸ”” Enable Alerts</label>
                                </div>
                                <div class="form-check form-switch mb-2">
                                    <input class="form-check-input" type="checkbox" id="enableSoundToggle">
                                    <label class="form-check-label" for="enableSoundToggle">ğŸ”Š Sound Alerts</label>
                                </div>
                                <div class="input-group input-group-sm mt-2">
                                    <input type="text" id="alertWebhookUrl" class="form-control" placeholder="Webhook URL (optional)">
                                    <button class="btn btn-outline-secondary" id="alertWebhookTest">Test</button>
                                </div>
                                <div class="form-check form-switch mt-2">
                                    <input class="form-check-input" type="checkbox" id="persistHistoryToggleAlt">
                                    <label class="form-check-label" for="persistHistoryToggleAlt">ğŸ’¾ Persist History (LocalStorage) â€” control</label>
                                </div>
                                <div class="form-text small text-muted mt-2">Alerts appear as a banner and can send webhooks when configured.</div>
                                <div id="alertsListContainer" class="mt-3">
                                    <div class="d-flex justify-content-between align-items-center mb-1">
                                        <h6 class="small text-muted mb-0">Recent Alerts</h6>
                                        <div>
                                            <button id="clearAlertsBtn" class="btn btn-sm btn-outline-danger">Clear</button>
                                        </div>
                                    </div>
                                    <div id="alertsList" class="list-group list-group-flush" style="max-height:240px;overflow:auto;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6" id="alertRulesNotesColumn">
                        <h6 class="text-success">Alert Rules & Notes</h6>
                        <div class="card bg-dark text-light mb-3">
                            <div class="card-body small">
                                <p>â€¢ Alert when Vol Ratio % (2h) &gt; 300% (strong buy)</p>
                                <p>â€¢ Alert when Vol Ratio % (2h) &lt; 30% (strong sell)</p>
                                <p>â€¢ Alert when Vol Ratio crosses 100%</p>
                                <p class="mt-2 text-muted">Use webhook test to verify delivery. Enable sound for audible alerts.</p>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <div class="tab-pane fade" id="spikes" role="tabpanel">
                <div class="table-responsive">
                    <table class="table table-striped" id="spikeTable">
                        <thead>
                            <tr>
                                <th>Coin</th>
                                <th>â± Timeframe</th>
                                <th>ğŸ“Š Vol</th>
                                <th>â— Avg</th>
                                <th>âš¡ Ratio</th>
                                <th>â° Update</th>
                            </tr>
                        </thead>
                        <tbody id="spikeBody"></tbody>
                    </table>
                </div>
            </div>
            <div class="tab-pane fade" id="recommendations" role="tabpanel">
                <div class="mb-2">
                    <div class="d-flex justify-content-between align-items-center flex-wrap">
                        <div class="input-group input-group-sm" style="width:160px;">
                            <span class="input-group-text">Timeframe</span>
                            <select id="recTimeframe" class="form-select">
                                <option value="All">All</option>
                                <option value="1m">1m</option>
                                <option value="5m">5m</option>
                                <option value="10m">10m</option>
                                <option value="30m">30m</option>
                                <option value="60m">60m</option>
                                <option value="120m">120m</option>
                                <option value="24h">24h</option>
                            </select>
                        </div>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="useAtrRecs">
                            <label class="form-check-label small text-muted" for="useAtrRecs">Use ATR-based TP/SL</label>
                        </div>
                        <div class="input-group input-group-sm" style="width:260px;">
                            <span class="input-group-text">TP% min / max</span>
                            <input type="number" id="tpMin" class="form-control" placeholder="min" value="2" step="0.1">
                            <input type="number" id="tpMax" class="form-control" placeholder="max" value="10" step="0.1">
                        </div>
                        <div class="input-group input-group-sm" style="width:160px;">
                            <span class="input-group-text">SL% max</span>
                            <input type="number" id="slMax" class="form-control" placeholder="max" value="5" step="0.1">
                        </div>
                        <div class="input-group input-group-sm" style="width:200px;">
                            <span class="input-group-text">Sens</span>
                            <input type="range" id="confSensitivity" min="0" max="2" step="0.05" value="1">
                        </div>
                    </div>
                </div>
                <div class="table-responsive">
                    <table class="table table-striped" id="recsTable">
                        <thead>
                            <tr>
                                <th>Coin</th>
                                <th>â± Timeframe</th>
                                <th>ğŸ¯ Recommendation</th>
                                <th>ğŸ” Confidence</th>
                                <th>ğŸ’° Price</th>
                                <th>ğŸ¯ TP</th>
                                <th>â›” SL</th>
                            </tr>
                        </thead>
                        <tbody id="recsBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>

        function CheckInfinity(value, avg) {
            const persentase = avg !== 0
                ? Math.round((value / avg) * 100)
                : 0; // Atur ke 0 jika rata-rata adalah 0
            return persentase;
        }


        const limitInput = document.getElementById('limitInput');
        const sortBySelect = document.getElementById('sortBy');
        // radio buttons for sort order
        const sortOrderRadios = document.getElementsByName('sortOrderRad');
        function getSortOrderValue() {
            try { for (const r of sortOrderRadios) if (r.checked) return r.value; } catch(e){}
            return 'desc';
        }
        let rowLimit = 5; // default rows to display (changed from 20)

        // Per-tab filter inputs
        const filterInputs = {
            summary: document.getElementById('coinFilter_summary'),
            volume: document.getElementById('coinFilter_volume'),
            volDur: document.getElementById('coinFilter_volDur'),
            spikes: document.getElementById('coinFilter_spikes'),
            recs: document.getElementById('coinFilter_recs'),
            alerts: document.getElementById('coinFilter_alerts')
        };

        // Debounce helper to reduce DOM churn from frequent updates
        function debounce(fn, wait) {
            let t = null;
            return function(...args) {
                if (t) clearTimeout(t);
                t = setTimeout(() => { try { fn.apply(this, args); } catch(e){}; t = null; }, wait);
            };
        }

        // Schedule updates to the table at most once per 150ms
        // `updateTable` is defined later; debounce will call it when available.
        const scheduleUpdateTable = debounce(function() {
            try { if (typeof updateTable === 'function') updateTable(); }
            catch(e) { /* ignore */ }
        }, 150);
        let activeFilterTab = 'summary';

        function setActiveFilterTab(tab) {
            activeFilterTab = tab || 'summary';
            for (const k in filterInputs) {
                try {
                    const el = filterInputs[k];
                    if (!el) continue;
                    if (k === activeFilterTab) el.classList.remove('d-none'); else el.classList.add('d-none');
                } catch(e){}
            }
        }

        function getActiveFilterValue() {
            try {
                const el = filterInputs[activeFilterTab];
                if (!el) return '';
                return (el.value || '').toLowerCase();
            } catch(e) { return ''; }
        }

        // Recommendation UI controls
        const useAtrRecs = document.getElementById('useAtrRecs');
        const tpMinInput = document.getElementById('tpMin');
        const tpMaxInput = document.getElementById('tpMax');
        const slMaxInput = document.getElementById('slMax');
        const confSensitivity = document.getElementById('confSensitivity');

        // Alerts compacting + hidden buffer
        const compactAlertsToggle = document.getElementById('compactAlertsToggle');
        const maxAlertBannersInput = document.getElementById('maxAlertBanners');
        const showHiddenAlertsBtn = document.getElementById('showHiddenAlertsBtn');
        // buffer for alerts suppressed while compact mode is on
        const hiddenAlertBuffer = window._hiddenAlertBuffer || (window._hiddenAlertBuffer = []);

        // load persisted compact preferences
        try {
            const savedCompact = localStorage.getItem('okx_compact_alerts');
            if (savedCompact !== null && compactAlertsToggle) compactAlertsToggle.checked = (savedCompact === 'true');
            const savedMax = localStorage.getItem('okx_max_alert_banners');
            if (savedMax !== null && maxAlertBannersInput) maxAlertBannersInput.value = Number(savedMax) || 3;
        } catch(e) { /* ignore */ }

        // Listen for changes to the limit
        limitInput.addEventListener('input', (event) => {
            rowLimit = parseInt(event.target.value, 10) || Infinity;
            scheduleUpdateTable(); // Update table when limit changes (debounced)
        });

        // Wire recommendation controls to refresh table when changed
        try {
            if (useAtrRecs) useAtrRecs.addEventListener('change', () => scheduleUpdateTable());
            if (tpMinInput) tpMinInput.addEventListener('input', () => scheduleUpdateTable());
            if (tpMaxInput) tpMaxInput.addEventListener('input', () => scheduleUpdateTable());
            if (slMaxInput) slMaxInput.addEventListener('input', () => scheduleUpdateTable());
            if (confSensitivity) confSensitivity.addEventListener('input', () => scheduleUpdateTable());
        } catch(e) { console.warn('wiring rec controls failed', e); }

        // Listen for changes in each per-tab filter input
        try {
            for (const k in filterInputs) {
                const el = filterInputs[k];
                if (!el) continue;
                el.addEventListener('input', () => scheduleUpdateTable());
            }
        } catch(e) { console.warn('wiring per-tab filters failed', e); }

        // Tab click handlers to switch active filter
        try {
            const tabMap = {
                'summary-tab': 'summary',
                'volume-tab': 'volume',
                'vol-dur-tab': 'volDur',
                'spike-tab': 'spikes',
                'recs-tab': 'recs',
                'alerts-tab': 'alerts',
                'insight-tab': 'summary',
                'info-tab': 'summary'
            };
            for (const tid in tabMap) {
                const btn = document.getElementById(tid);
                if (!btn) continue;
                btn.addEventListener('click', () => setActiveFilterTab(tabMap[tid]));
            }
        } catch(e) { console.warn('wiring tab filter toggles failed', e); }

        // show default filter
        setActiveFilterTab('summary');

        // Wire compact alert controls
        try {
            if (compactAlertsToggle) compactAlertsToggle.addEventListener('change', (ev) => {
                try { localStorage.setItem('okx_compact_alerts', ev.target.checked ? 'true' : 'false'); } catch(e){}
            });
            if (maxAlertBannersInput) maxAlertBannersInput.addEventListener('input', (ev) => {
                try { localStorage.setItem('okx_max_alert_banners', String(parseInt(ev.target.value,10) || 0)); } catch(e){}
            });
            if (showHiddenAlertsBtn) showHiddenAlertsBtn.addEventListener('click', (ev) => {
                try {
                    // populate modal with hidden alerts
                    const modalBody = document.getElementById('hiddenAlertsModalBody');
                    if (!modalBody) return;
                    modalBody.innerHTML = '';
                    if (!hiddenAlertBuffer || hiddenAlertBuffer.length === 0) {
                        modalBody.innerHTML = '<div class="small text-muted">No hidden alerts</div>';
                    } else {
                        for (const a of hiddenAlertBuffer) {
                            const div = document.createElement('div');
                            div.className = 'mb-2 p-2 bg-dark text-light';
                            div.innerHTML = `<strong>${a.title}</strong><div style="font-size:0.9em;">${a.message}</div><div class="text-muted small">${new Date(a.ts).toLocaleString()}</div>`;
                            modalBody.appendChild(div);
                        }
                    }
                    const bs = new bootstrap.Modal(document.getElementById('hiddenAlertsModal'));
                    bs.show();
                } catch(e) { console.warn('showHiddenAlerts failed', e); }
            });
        } catch(e) { console.warn('wiring compact alert controls failed', e); }

        // Listen for changes in sort criteria
        sortBySelect.addEventListener('change', () => {
            scheduleUpdateTable(); // Update table when sort criteria is changed (debounced)
        });

        // Listen for changes in sort order (radio buttons)
        try {
            for (const r of sortOrderRadios) { if (r) r.addEventListener('change', () => scheduleUpdateTable()); }
        } catch(e) { console.warn('wiring sort order radios failed', e); }

        const summaryBody = document.getElementById('summaryBody');
        const volBody = document.getElementById('volBody');
        const volRatioBody = document.getElementById('volRatioBody');
        const spikeBody = document.getElementById('spikeBody');
        const recsBody = document.getElementById('recsBody');
        const recTimeframeSelect = document.getElementById('recTimeframe');
        const openRecsBtn = document.getElementById('openRecsBtn');

        if (openRecsBtn) {
            openRecsBtn.addEventListener('click', () => {
                try { const tab = document.getElementById('recs-tab'); if (tab) tab.click(); } catch(e) { console.warn('openRecs click failed', e); }
            });
        }
        if (recTimeframeSelect) recTimeframeSelect.addEventListener('change', () => scheduleUpdateTable());
                let ws = null;

                // Attach handlers to a WebSocket instance by binding the named handlers
                function attachHandlers(socket) {
                    if (!socket) return;
                    socket.onopen = onWsOpen;
                    socket.onmessage = onWsMessage;
                    socket.onclose = (ev) => { console.log('WebSocket closed', ev && ev.code); };
                    socket.onerror = (err) => { console.error('WebSocket error', err); };
                }

                function createAndAttach() {
                    try {
                        if (ws) try { ws.close(); } catch(e){}
                    } catch(e){}
                    ws = new WebSocket('wss://eofficev2.bekasikota.go.id/okx-ws');
                    attachHandlers(ws);
                }

                // create initial connection
                createAndAttach();

                // restart connection every 20 seconds
                const RESTART_INTERVAL_MS = 20 * 1000;
                setInterval(() => {
                    try {
                        console.log('Restarting WebSocket connection (interval)');
                        createAndAttach();
                    } catch (e) { console.warn('WebSocket restart failed', e); }
                }, RESTART_INTERVAL_MS);

                // --- Insight modal helpers (ensure global functions available) ---
                function ensureInsightModal() {
                        if (document.getElementById('insightModal')) return;
                        const wrapper = document.createElement('div');
                        wrapper.innerHTML = `
                        <div class="modal fade" id="insightModal" tabindex="-1" aria-hidden="true">
                            <div class="modal-dialog modal-lg modal-dialog-centered">
                                <div class="modal-content">
                                    <div class="modal-header">
                                        <h5 class="modal-title" id="insightModalLabel">Insight</h5>
                                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                    </div>
                                    <div class="modal-body" id="insightModalBody">
                                        <!-- populated dynamically -->
                                    </div>
                                    <div class="modal-footer">
                                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                        <button type="button" class="btn btn-outline-primary" id="insightExportJson">Export JSON</button>
                                        <button type="button" class="btn btn-outline-success" id="insightExportCsv">Export CSV</button>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                                                document.body.appendChild(wrapper.firstElementChild);
                                }

                                // --- Test JSON modal helper ---
                                function ensureTestJsonModal() {
                                        if (document.getElementById('testJsonModal')) return;
                                        const w = document.createElement('div');
                                        w.innerHTML = `
                                        <div class="modal fade" id="testJsonModal" tabindex="-1" aria-hidden="true">
                                            <div class="modal-dialog modal-lg modal-dialog-centered">
                                                <div class="modal-content">
                                                    <div class="modal-header">
                                                        <h5 class="modal-title">Run JSON (Paste & Run)</h5>
                                                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                                    </div>
                                                    <div class="modal-body">
                                                        <p class="small text-muted">Paste a single JSON payload here and click <strong>Run</strong> to simulate receiving it from WebSocket.</p>
                                                        <textarea id="testJsonTextarea" class="form-control" rows="8" placeholder='Paste JSON here'></textarea>
                                                        <div id="testJsonError" class="text-danger small mt-2" style="display:none"></div>
                                                    </div>
                                                    <div class="modal-footer">
                                                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                                                        <button type="button" class="btn btn-primary" id="testJsonRunBtn">Run</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>`;
                                        document.body.appendChild(w.firstElementChild);
                                }

                function drawSparkline(history, width = 600, height = 80) {
                        if (!history || history.length === 0) return '';
                        const vals = history.map(h => Number(h.price || h.volBuy2h || h.volSell2h || 0));
                        const min = Math.min(...vals);
                        const max = Math.max(...vals);
                        const range = (max - min) || 1;
                        const step = width / Math.max(1, vals.length - 1);
                        const points = vals.map((v, i) => {
                                const x = Math.round(i * step);
                                const y = Math.round(height - ((v - min) / range) * height);
                                return `${x},${y}`;
                        }).join(' ');
                        return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg"><polyline fill="none" stroke="#0d6efd" stroke-width="2" points="${points}"/></svg>`;
                }

                // --- Alerts: banner, sound, webhook ---
                const ALERT_ENABLED_KEY = 'okx_calc_alerts_enabled';
                let storedAlertEnabled = false;
                try {
                    storedAlertEnabled = localStorage.getItem(ALERT_ENABLED_KEY) === 'true';
                } catch (e) { storedAlertEnabled = false; }
                const alertState = {
                    enabled: storedAlertEnabled,
                    sound: false,
                    webhook: ''
                };

                function syncAlertNotesVisibility() {
                    try {
                        const col = document.getElementById('alertRulesNotesColumn');
                        if (col) col.style.display = alertState.enabled ? '' : 'none';
                    } catch (e) { console.warn('alert notes visibility sync failed', e); }
                }
                const lastAlertAt = {}; // per-coin throttle
                // Whether to persist per-coin history to localStorage (default: enabled)
                let persistHistoryEnabled = (localStorage.getItem('okx_calc_persist') !== 'false');

                // create banner container
                (function(){
                    const b = document.createElement('div');
                    b.id = 'alertBanner';
                    b.style.position = 'fixed';
                    b.style.left = '12px';
                    b.style.top = '12px';
                    b.style.zIndex = 3000;
                    b.style.maxWidth = 'min(600px, 90vw)';
                    document.body.appendChild(b);
                })();

                // simple sound element
                const _alertAudio = document.createElement('audio');
                _alertAudio.src = 'data:audio/ogg;base64,T2dnUwACAAAAAAAAAABVDwAAAAAA...'; // tiny placeholder (silent) - replace if needed
                _alertAudio.preload = 'auto';
                document.body.appendChild(_alertAudio);

                function showAlertBanner(title, message, type = 'info', timeout = 1500) {
                    if (!alertState.enabled) return;
                    const container = document.getElementById('alertBanner');
                    if (!container) return;
                    // Respect compact alerts setting: if compact enabled and visible banners >= max, skip showing banner
                    try {
                        const compactEl = document.getElementById('compactAlertsToggle');
                        const maxEl = document.getElementById('maxAlertBanners');
                        const compactEnabled = compactEl ? !!compactEl.checked : false;
                        const maxVisible = maxEl ? (parseInt(maxEl.value, 10) || 0) : 3;
                        if (compactEnabled && (maxVisible <= 0 || container.children.length >= maxVisible)) {
                                // store suppressed alert in buffer, still record in Alerts tab and optionally play sound/webhook
                                try { hiddenAlertBuffer.push({ title, message, type, ts: Date.now() }); } catch(e){}
                                try { if (alertState.sound) { _alertAudio.currentTime = 0; _alertAudio.play().catch(()=>{}); } } catch(e){}
                                try { let coin = null; if (typeof title === 'string' && title.indexOf('â€”') !== -1) coin = title.split('â€”')[0].trim(); addAlertToTab(coin, message, type, Date.now()); } catch(e){}
                                return;
                        }
                    } catch(e) { /* ignore compact check errors and continue to show banner */ }
                    const el = document.createElement('div');
                    el.className = 'alert';
                    el.style.marginBottom = '8px';
                    el.style.cursor = 'pointer';
                    el.style.opacity = '0.98';
                    el.style.backdropFilter = 'blur(6px)';
                    if (type === 'danger') el.classList.add('alert-danger');
                    else if (type === 'warning') el.classList.add('alert-warning');
                    else el.classList.add('alert-info');
                    // include explicit close button to ensure users can dismiss banners
                    el.innerHTML = `
                        <div style="display:flex;justify-content:space-between;align-items:flex-start;">
                            <div style="flex:1;">
                                <strong>${title}</strong>
                                <div style="font-size:0.9em;margin-top:4px;">${message}</div>
                            </div>
                            <button type="button" aria-label="Close" title="Close" class="btn-close btn-close-white" style="margin-left:12px;" />
                        </div>
                    `;
                    try {
                        const closeBtn = el.querySelector('.btn-close');
                        if (closeBtn) closeBtn.addEventListener('click', (ev) => { try { ev.stopPropagation(); el.remove(); } catch(e){} });
                    } catch(e){}
                    // also allow clicking the banner body to remove it (defensive)
                    el.addEventListener('click', (ev) => { try { if (ev && ev.target && ev.target.classList && ev.target.classList.contains('btn-close')) return; el.remove(); } catch(e){} });
                    container.appendChild(el);
                    if (alertState.sound) try { _alertAudio.currentTime = 0; _alertAudio.play().catch(()=>{}); } catch(e){}
                    setTimeout(()=>{ try { if (el && el.parentElement) el.remove(); } catch(e){} }, timeout);
                    // Also append this alert into the Alerts tab list for persistence/visibility
                    try {
                        // derive coin if present in title (format: 'COIN â€” Alert')
                        let coin = null;
                        if (typeof title === 'string' && title.indexOf('â€”') !== -1) coin = title.split('â€”')[0].trim();
                        addAlertToTab(coin, message, type, Date.now());
                    } catch (e) { console.warn('addAlertToTab failed', e); }
                }

                async function sendAlertWebhook(coin, insights) {
                    try {
                        const url = (document.getElementById('alertWebhookUrl') && document.getElementById('alertWebhookUrl').value) || alertState.webhook || '';
                        if (!url) return;
                        await fetch(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ coin, insights, ts: Date.now() }) });
                    } catch (e) { console.warn('Webhook send failed', e); }
                }

                // wire UI controls (if present)
                try {
                    const eToggle = document.getElementById('enableAlertsToggle');
                    const sToggle = document.getElementById('enableSoundToggle');
                    const wInput = document.getElementById('alertWebhookUrl');
                    const wTest = document.getElementById('alertWebhookTest');
                    if (eToggle) {
                        eToggle.checked = !!alertState.enabled;
                        alertState.enabled = !!eToggle.checked;
                        eToggle.addEventListener('change', (ev)=> {
                            alertState.enabled = !!ev.target.checked;
                            try { localStorage.setItem(ALERT_ENABLED_KEY, alertState.enabled ? 'true' : 'false'); } catch(e){}
                            syncAlertNotesVisibility();
                        });
                    }
                    if (sToggle) { alertState.sound = !!sToggle.checked; sToggle.addEventListener('change', (ev)=> alertState.sound = !!ev.target.checked); }
                    if (wInput) { wInput.addEventListener('input', (ev)=> alertState.webhook = ev.target.value); if (localStorage.getItem('okx_calc_webhook')) { wInput.value = localStorage.getItem('okx_calc_webhook'); alertState.webhook = wInput.value; } }
                    if (wTest) wTest.addEventListener('click', ()=> { showAlertBanner('Webhook test', 'Sending test payload...', 'info', 3000); sendAlertWebhook('TEST', { test: true }); try { localStorage.setItem('okx_calc_webhook', (wInput && wInput.value) || ''); } catch(e){} });
                    // Defensive: ensure toggles and labels accept pointer events (fixes cases where overlays/CSS block clicks)
                    try {
                        if (eToggle) {
                            try { eToggle.style.pointerEvents = 'auto'; if (eToggle.parentElement) eToggle.parentElement.style.pointerEvents = 'auto'; } catch(e){}
                            const lbl = document.querySelector('label[for="enableAlertsToggle"]');
                            if (lbl) {
                                lbl.style.cursor = 'pointer';
                                // ensure clicking the label toggles the checkbox in case implicit label->input isn't working
                                lbl.addEventListener('click', (ev) => {
                                    try {
                                        ev.preventDefault();
                                        ev.stopPropagation();
                                        eToggle.checked = !eToggle.checked;
                                        eToggle.dispatchEvent(new Event('change'));
                                    } catch(e){}
                                });
                            }
                        }
                        if (sToggle) { try { sToggle.style.pointerEvents = 'auto'; if (sToggle.parentElement) sToggle.parentElement.style.pointerEvents = 'auto'; } catch(e){} }
                    } catch(e) { console.warn('defensive toggle wiring failed', e); }
                    // Alt persist toggle in alerts tab (mirror header control)
                    try {
                        const alt = document.getElementById('persistHistoryToggleAlt');
                        const main = document.getElementById('persistHistoryToggle');
                        if (alt) {
                            // initialize state from saved preference
                            alt.checked = persistHistoryEnabled;
                            alt.addEventListener('change', (ev) => {
                                persistHistoryEnabled = !!ev.target.checked;
                                try { if (main) { main.checked = persistHistoryEnabled; } localStorage.setItem('okx_calc_persist', persistHistoryEnabled ? 'true' : 'false'); } catch(e){}
                            });
                        }
                        if (main && alt) {
                            // also sync main -> alt when main changes
                            main.addEventListener('change', (ev) => {
                                try { alt.checked = !!ev.target.checked; } catch(e){}
                            });
                        }
                    } catch(e) { console.warn('alt persist wiring failed', e); }
                } catch(e){ console.warn('alert UI wiring error', e); }
                syncAlertNotesVisibility();

                // Alerts storage and rendering in Alerts tab
                const ALERTS_KEY = 'okx_calc_alerts_v1';
                const ALERT_RULES_KEY = 'okx_calc_alert_rules_v1';

                // Default alert rules seed (applied if no rules found in localStorage)
                const DEFAULT_ALERT_RULES = [
                    { id: 'vol_ratio_buy_high', name: 'Vol Ratio 2h > 200%', metric: 'vol_ratio_2h', op: '>', threshold: 200, severity: 'warning', enabled: true, message: 'Vol Ratio % (2h) > 200% (strong buy pressure)'} ,
                    { id: 'vol_ratio_sell_low', name: 'Vol Ratio 2h < 30%', metric: 'vol_ratio_2h', op: '<', threshold: 30, severity: 'danger', enabled: true, message: 'Vol Ratio % (2h) < 30% (strong sell pressure)'} ,
                    { id: 'freq_vs_avg_buy', name: 'Freq Buy vs Avg > 200%', metric: 'freq_vs_avg_buy_percent', op: '>', threshold: 200, severity: 'warning', enabled: true, message: 'Frequency buy >> historical average (>=200%)'}
                ];

                function loadAlertRules() {
                    try {
                        const arr = JSON.parse(localStorage.getItem(ALERT_RULES_KEY) || 'null');
                        if (!arr || !Array.isArray(arr) || arr.length === 0) {
                            // seed defaults
                            try { localStorage.setItem(ALERT_RULES_KEY, JSON.stringify(DEFAULT_ALERT_RULES)); } catch(e){}
                            return DEFAULT_ALERT_RULES.slice();
                        }
                        return arr;
                    } catch (e) { return DEFAULT_ALERT_RULES.slice(); }
                }

                function saveAlertRules(arr) {
                    try { localStorage.setItem(ALERT_RULES_KEY, JSON.stringify(arr || [])); } catch (e) { console.warn('saveAlertRules failed', e); }
                }

                function renderAlertRules() {
                    try {
                        const container = document.getElementById('alertsListContainer');
                        if (!container) return;
                        let panel = document.getElementById('alertRulesPanel');
                        if (!panel) {
                            panel = document.createElement('div');
                            panel.id = 'alertRulesPanel';
                            panel.className = 'mt-3';
                            container.appendChild(panel);
                        }
                        const rules = loadAlertRules();
                        let html = '<h6 class="small text-muted mb-1">Alert Rules</h6>';
                        if (!rules || rules.length === 0) html += '<div class="small text-muted">No alert rules configured</div>';
                        else {
                            html += '<div class="list-group list-group-flush small" style="max-height:180px;overflow:auto;">';
                            for (const r of rules) {
                                const badge = r.severity === 'danger' ? '<span class="badge bg-danger me-1">!</span>' : '<span class="badge bg-warning text-dark me-1">!</span>';
                                const enabled = r.enabled ? '' : ' <span class="text-muted">(disabled)</span>';
                                html += `<div class="list-group-item bg-dark text-light">${badge}<strong>${r.name}</strong>${enabled}<div class="text-muted small">${r.message || ''} â€” <em>${r.metric} ${r.op} ${r.threshold}</em></div></div>`;
                            }
                            html += '</div>';
                        }
                        panel.innerHTML = html;
                    } catch(e) { console.warn('renderAlertRules failed', e); }
                }

                // in-memory cooldown per coin+rule to prevent spam (ms)
                const ALERT_RULE_COOLDOWN_MS = 60 * 1000; // 60s per rule
                const lastAlertRuleAt = {};

                function evaluateAlertRulesForData(data) {
                    try {
                        if (!data || !data.coin) return;
                        const rules = loadAlertRules();
                        if (!rules || rules.length === 0) return;
                        const a = data._analytics || {};
                        for (const r of rules) {
                            try {
                                if (!r.enabled) continue;
                                // fetch metric value: prefer analytics fields
                                let val = null;
                                switch (r.metric) {
                                    case 'vol_ratio_2h':
                                        val = (a.volRatioBuySell_percent !== undefined) ? a.volRatioBuySell_percent : ( (getNumeric(data,'count_VOL_minute_120_buy') || 0) / Math.max((getNumeric(data,'count_VOL_minute_120_sell')||0),1) * 100 );
                                        break;
                                    case 'freq_vs_avg_buy_percent':
                                        val = a.freqBuy_vs_avg_percent !== undefined ? a.freqBuy_vs_avg_percent : ( (getNumeric(data,'count_FREQ_minute_120_buy') || a.freqBuy2h || 0) / Math.max((getNumeric(data,'avg_FREQCOIN_buy_2JAM')||a.avgFreqBuy2h||1),1) * 100 );
                                        break;
                                    case 'freq_ratio_2h':
                                        val = (a.freqBuy2h !== undefined && a.freqSell2h !== undefined) ? ( (Number(a.freqBuy2h) / Math.max(Number(a.freqSell2h),1)) * 100 ) : null;
                                        break;
                                    default:
                                        // try direct analytics field
                                        val = a[r.metric] !== undefined ? a[r.metric] : null;
                                }
                                if (val === null || val === undefined) continue;
                                let triggered = false;
                                if (r.op === '>' && Number(val) > Number(r.threshold)) triggered = true;
                                if (r.op === '<' && Number(val) < Number(r.threshold)) triggered = true;
                                if (!triggered) continue;
                                const key = `${data.coin}::${r.id}`;
                                const now = Date.now();
                                if (lastAlertRuleAt[key] && (now - lastAlertRuleAt[key] < ALERT_RULE_COOLDOWN_MS)) continue; // cooldown
                                lastAlertRuleAt[key] = now;
                                // trigger alert
                                const title = `${data.coin} â€” Alert: ${r.name}`;
                                const msg = `${r.message || ''} (value: ${Math.round(Number(val)*100)/100})`;
                                showAlertBanner(title, msg, r.severity === 'danger' ? 'danger' : 'warning', 8000);
                                addAlertToTab(data.coin, msg, r.severity === 'danger' ? 'danger' : 'warning', now);
                                // optional webhook
                                try { sendAlertWebhook(data.coin, { rule: r, value: val, ts: now }); } catch(e){}
                            } catch(e) { console.warn('evaluate rule failed', e); }
                        }
                    } catch(e) { console.warn('evaluateAlertRulesForData failed', e); }
                }

                function loadAlertsFromStore() {
                    try {
                        const arr = JSON.parse(localStorage.getItem(ALERTS_KEY) || '[]');
                        return Array.isArray(arr) ? arr : [];
                    } catch (e) { return []; }
                }

                function saveAlertsToStore(arr) {
                    try { localStorage.setItem(ALERTS_KEY, JSON.stringify(arr || [])); } catch (e) { }
                }

                function formatTs(ts) {
                    try { const d = new Date(ts); return d.toLocaleString(); } catch (e) { return String(ts); }
                }

                function renderAlertsList() {
                    try {
                        const container = document.getElementById('alertsList');
                        if (!container) return;
                        const arr = loadAlertsFromStore();
                        container.innerHTML = '';
                        for (let i = arr.length - 1; i >= 0; i--) {
                            const it = arr[i];
                            const el = document.createElement('div');
                            el.className = 'list-group-item bg-dark text-light small';
                            el.style.border = '1px solid rgba(255,255,255,0.04)';
                            el.innerHTML = `<div class="d-flex w-100 justify-content-between"><strong>${it.coin?it.coin+' â€” ':' '}${it.type && it.type==='warning'?'<span class="badge bg-warning text-dark">Alert</span>':''}${it.type && it.type==='danger'?'<span class="badge bg-danger">Alert</span>':''}</strong><small class="text-muted">${formatTs(it.ts)}</small></div><div style="font-size:0.9em;margin-top:4px;color:#cbd5e1;">${it.message}</div>`;
                            container.appendChild(el);
                        }
                    } catch(e) { console.warn('renderAlertsList error', e); }
                }

                // Clear alerts & wire Clear button
                function clearAlerts() {
                    try {
                        saveAlertsToStore([]);
                        renderAlertsList();
                        showAlertBanner('Alerts cleared', 'All stored alerts were removed', 'info', 3000);
                    } catch (e) { console.warn('clearAlerts failed', e); }
                }

                try {
                    const clearBtn = document.getElementById('clearAlertsBtn');
                    if (clearBtn) clearBtn.addEventListener('click', () => {
                        if (!confirm('Clear all stored alerts?')) return;
                        clearAlerts();
                    });
                } catch(e) { console.warn('clearAlerts button wiring failed', e); }

                function addAlertToTab(coin, message, type='info', ts=Date.now()) {
                    try {
                        const arr = loadAlertsFromStore();
                        arr.push({ coin: coin || null, message: String(message || ''), type: type || 'info', ts: ts || Date.now() });
                        // keep recent N alerts
                        const MAX_ALERTS = 300;
                        if (arr.length > MAX_ALERTS) arr.splice(0, arr.length - MAX_ALERTS);
                        saveAlertsToStore(arr);
                        renderAlertsList();
                    } catch (e) { console.warn('addAlertToTab failed', e); }
                }

                // render stored alerts and rules on load
                try { renderAlertsList(); } catch(e) {}
                try { if (typeof renderAlertRules === 'function') renderAlertRules(); } catch(e) {}

                // --- Persistence (LocalStorage) helpers ---
                const PERSIST_KEY = 'okx_calc_history_v1';
                const MAX_HISTORY = 500; // keep up to this many points per coin
                // `persistHistoryEnabled` is declared earlier near other state variables to avoid TDZ
                const _lastSaveAt = {};

                function loadPersistedHistory(coin) {
                    try {
                        const store = JSON.parse(localStorage.getItem(PERSIST_KEY) || '{}');
                        const arr = store && store[coin] ? store[coin] : [];
                        return Array.isArray(arr) ? arr.slice(-MAX_HISTORY) : [];
                    } catch (e) { console.warn('loadPersistedHistory error', e); return []; }
                }

                function savePersistedHistory(coin, arr) {
                    if (!persistHistoryEnabled) return;
                    try {
                        const now = Date.now();
                        if (_lastSaveAt[coin] && (now - _lastSaveAt[coin]) < 5000) return; // throttle 5s
                        _lastSaveAt[coin] = now;
                        const store = JSON.parse(localStorage.getItem(PERSIST_KEY) || '{}');
                        store[coin] = arr.slice(-MAX_HISTORY);
                        localStorage.setItem(PERSIST_KEY, JSON.stringify(store));
                    } catch (e) { console.warn('savePersistedHistory error', e); }
                }

                // Wire the UI toggle
                try {
                    const t = document.getElementById('persistHistoryToggle');
                    if (t) {
                        // Ensure toggle reflects saved preference
                        t.checked = persistHistoryEnabled;
                        // Defensive: make sure the toggle and its parent accept pointer events
                        try { t.style.pointerEvents = 'auto'; if (t.parentElement) t.parentElement.style.pointerEvents = 'auto'; } catch(e){}
                        // Wire change handler
                        t.addEventListener('change', (ev) => {
                            persistHistoryEnabled = !!ev.target.checked;
                            try { localStorage.setItem('okx_calc_persist', persistHistoryEnabled ? 'true' : 'false'); } catch(e){}
                        });
                        // Also make the label clickable (some layouts may overlay the checkbox)
                        try {
                            const lbl = document.querySelector('label[for="persistHistoryToggle"]');
                            if (lbl) {
                                lbl.style.cursor = 'pointer';
                                lbl.addEventListener('click', (ev) => {
                                    // toggle checkbox programmatically and fire change
                                    try { t.checked = !t.checked; t.dispatchEvent(new Event('change')); } catch(e){}
                                });
                            }
                        } catch(e) { console.warn('persist label wiring failed', e); }
                    }
                } catch (e) { console.warn('persist toggle wiring failed', e); }

                // Global error display for debugging (shows last uncaught error on page)
                window.__displayError = function(err) {
                    try {
                        console.error('Captured Error:', err);
                        let el = document.getElementById('lastError');
                        if (!el) {
                            el = document.createElement('div');
                            el.id = 'lastError';
                            el.style.position = 'fixed';
                            el.style.right = '12px';
                            el.style.bottom = '12px';
                            el.style.zIndex = 2000;
                            el.style.background = 'rgba(220,53,69,0.95)';
                            el.style.color = '#fff';
                            el.style.padding = '8px 12px';
                            el.style.borderRadius = '6px';
                            el.style.fontSize = '12px';
                            document.body.appendChild(el);
                        }
                        el.textContent = typeof err === 'string' ? err : (err && err.stack) ? err.stack.split('\n')[0] : String(err);
                    } catch (e) { console.error('Error displaying error', e); }
                };

                window.addEventListener('error', function(ev) { window.__displayError(ev.error || ev.message || 'Unknown error'); });
                window.addEventListener('unhandledrejection', function(ev) { window.__displayError(ev.reason || ev.reason && ev.reason.message || 'Unhandled rejection'); });

                window.exportInsightJSON = function(coin, data) {
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${coin}-insight.json`;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        URL.revokeObjectURL(url);
                };

                window.exportInsightCSV = function(coin, data) {
                        // export history points and a few summary fields
                        const rows = [];
                        rows.push(['coin', coin]);
                        rows.push(['risk_score', data.risk_score || (data._analytics && data._analytics.riskScore) || 0]);
                        rows.push([]);
                        rows.push(['ts','price','volBuy2h','volSell2h']);
                        const hist = data._history || [];
                        for (const h of hist) rows.push([h.ts || '', h.price || '', h.volBuy2h || '', h.volSell2h || '']);
                        const csv = rows.map(r => r.map(c => String(c).replace(/"/g,'""')).map(c => `"${c}"`).join(',')).join('\n');
                        const blob = new Blob([csv], { type: 'text/csv' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${coin}-insight.csv`;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        URL.revokeObjectURL(url);
                };

                window.showInsightModal = function(coin, data) {
                        ensureInsightModal();
                        const modalEl = document.getElementById('insightModal');
                        const body = document.getElementById('insightModalBody');
                        const title = document.getElementById('insightModalLabel');
                        title.textContent = `Insights â€” ${coin}`;

                        const risk = data.risk_score || (data._analytics && data._analytics.riskScore) || 0;
                        const comp = (data._analytics && data._analytics.components) || {};
                        const hist = data._history || [];
                        // prepare z-score / persistence diagnostics
                        const buySeries = hist.map(h => Number(h.volBuy2h || 0));
                        const sellSeries = hist.map(h => Number(h.volSell2h || 0));
                        function meanStd(arr) {
                            if (!arr || arr.length === 0) return { mean: 0, std: 0 };
                            const m = arr.reduce((s, v) => s + v, 0) / arr.length;
                            const varr = arr.reduce((s, v) => s + Math.pow(v - m, 2), 0) / arr.length;
                            return { mean: m, std: Math.sqrt(varr) };
                        }
                        const buyStat = meanStd(buySeries);
                        const sellStat = meanStd(sellSeries);
                        const currBuy = Number((data._analytics && data._analytics.volBuy2h) || getNumeric(data, 'count_VOL_minute_120_buy', 'vol_buy_2JAM') || 0);
                        const currSell = Number((data._analytics && data._analytics.volSell2h) || getNumeric(data, 'count_VOL_minute_120_sell', 'vol_sell_2JAM') || 0);
                        const zBuy = (buySeries.length >= 6 && buyStat.std > 0) ? ((currBuy - buyStat.mean) / buyStat.std) : null;
                        const zSell = (sellSeries.length >= 6 && sellStat.std > 0) ? ((currSell - sellStat.mean) / sellStat.std) : null;
                        // persistence: last 3 buys > mean+std
                        let persistBuy = null;
                        if (buySeries.length >= 3 && buyStat.std > 0) {
                            const recent = buySeries.slice(Math.max(0, buySeries.length - 3));
                            persistBuy = recent.filter(v => v > (buyStat.mean + buyStat.std)).length;
                        }

                        body.innerHTML = `
                                <div class="mb-3">
                                    <strong>Risk Score:</strong> <span class="fw-bold">${risk}%</span>
                                </div>
                                <div class="row mb-3">
                                    <div class="col-12">${drawSparkline(hist, 560, 90)}</div>
                                </div>
                                <div class="row">
                                    <div class="col-md-6">
                                        <h6>Components</h6>
                                        <ul>
                                            <li>Imbalance: ${Number(comp.imbalance || 0).toFixed(2)}</li>
                                            <li>Deviation: ${Number(comp.deviation || 0).toFixed(2)}</li>
                                            <li>Price Move: ${Number(comp.priceMove || 0).toFixed(2)}</li>
                                            <li>Liquidity: ${Number(comp.liquidity || 0).toFixed(2)}</li>
                                        </ul>
                                    </div>
                                    <div class="col-md-6">
                                        <h6>Summary</h6>
                                        <table class="table table-sm">
                                            <tr><td>Vol Buy (2h)</td><td>${getNumeric(data,'count_VOL_minute_120_buy','vol_buy_2JAM') || 0}</td></tr>
                                            <tr><td>Vol Sell (2h)</td><td>${getNumeric(data,'count_VOL_minute_120_sell','vol_sell_2JAM') || 0}</td></tr>
                                            <tr><td>Vol Dur (2h)</td><td>${getNumeric(data,'percent_sum_VOL_minute_120_buy') || data.percent_sum_VOL_minute_120_buy || 0}%</td></tr>
                                            <tr><td>Price</td><td>${data.last || 0}</td></tr>
                                        </table>
                                        <div class="small text-muted mt-2">
                                            <strong>Buy z-score (2h):</strong> ${zBuy === null ? 'N/A' : Number(zBuy.toFixed(2))}
                                            <br><small>Samples: ${buySeries.length} | mean: ${Number(buyStat.mean.toFixed(2))} | std: ${Number(buyStat.std.toFixed(2))}</small>
                                            <br><strong>Sell z-score (2h):</strong> ${zSell === null ? 'N/A' : Number(zSell.toFixed(2))}
                                            <br><small>Samples: ${sellSeries.length} | mean: ${Number(sellStat.mean.toFixed(2))} | std: ${Number(sellStat.std.toFixed(2))}</small>
                                            <br><strong>Persistence (last3 buys > mean+std):</strong> ${persistBuy === null ? '-' : persistBuy}
                                        </div>
                                    </div>
                                </div>`;

                        // wire export buttons
                        const btnJson = document.getElementById('insightExportJson');
                        const btnCsv = document.getElementById('insightExportCsv');
                        btnJson.onclick = () => window.exportInsightJSON(coin, data);
                        btnCsv.onclick = () => window.exportInsightCSV(coin, data);

                        // show modal using Bootstrap
                        try {
                                const bsModal = new bootstrap.Modal(modalEl);
                                bsModal.show();
                        } catch (e) {
                                console.warn('Bootstrap modal not available, falling back to alert', e);
                                alert(`${coin} â€” Risk: ${risk}%`);
                        }
                };

                // Show insight in the Insight tab (populate the insight pane and activate the tab)
                window.showInsightTab = function(coin, data) {
                    try {
                        const pane = document.getElementById('insightPaneBody');
                        if (!pane) return showInsightModal(coin, data);
                        const risk = data.risk_score || (data._analytics && data._analytics.riskScore) || 0;
                        const comp = (data._analytics && data._analytics.components) || {};
                        const hist = data._history || [];
                        // compute price position
                        const currentPrice = parseFloat(data.last) || 0;
                        const highPrice = parseFloat(data.high) || currentPrice;
                        const lowPrice = parseFloat(data.low) || currentPrice;
                        const priceRange = highPrice - lowPrice;
                        const pricePos = priceRange > 0 ? Math.round(((currentPrice - lowPrice) / priceRange) * 100) : 50;

                        // recommendation breakdown
                        const rec = (typeof calculateRecommendation === 'function') ? calculateRecommendation(data, pricePos, null, false) : { recommendation: 'N/A', className: '', score:0, confidence:0 };

                        // timeframes to show
                        const tfs = [
                            {k:'1m', buyKeys:['count_VOL_minute1_buy','vol_buy_1MENIT','vol_buy_1m'], sellKeys:['count_VOL_minute1_sell','vol_sell_1MENIT','vol_sell_1m'], avgKeys:['avg_VOLCOIN_buy_1MENIT']},
                            {k:'5m', buyKeys:['count_VOL_minute_5_buy','vol_buy_5MENIT','vol_buy_5m'], sellKeys:['count_VOL_minute_5_sell','vol_sell_5MENIT','vol_sell_5m'], avgKeys:['avg_VOLCOIN_buy_5MENIT']},
                            {k:'10m', buyKeys:['count_VOL_minute_10_buy','vol_buy_10MENIT','vol_buy_10m'], sellKeys:['count_VOL_minute_10_sell','vol_sell_10MENIT','vol_sell_10m'], avgKeys:['avg_VOLCOIN_buy_10MENIT']},
                            {k:'15m', buyKeys:['count_VOL_minute_15_buy','vol_buy_15MENIT','vol_buy_15m'], sellKeys:['count_VOL_minute_15_sell','vol_sell_15MENIT','vol_sell_15m'], avgKeys:['avg_VOLCOIN_buy_15MENIT']},
                            {k:'30m', buyKeys:['count_VOL_minute_30_buy','vol_buy_30MENIT','vol_buy_30m'], sellKeys:['count_VOL_minute_30_sell','vol_sell_30MENIT','vol_sell_30m'], avgKeys:['avg_VOLCOIN_buy_30MENIT']},
                            {k:'60m', buyKeys:['count_VOL_minute_60_buy','vol_buy_1JAM','vol_buy_60MENIT'], sellKeys:['count_VOL_minute_60_sell','vol_sell_1JAM','vol_sell_60MENIT'], avgKeys:['avg_VOLCOIN_buy_1JAM']},
                            {k:'120m', buyKeys:['count_VOL_minute_120_buy','vol_buy_2JAM','vol_buy_120MENIT'], sellKeys:['count_VOL_minute_120_sell','vol_sell_2JAM','vol_sell_120MENIT'], avgKeys:['avg_VOLCOIN_buy_2JAM']},
                            {k:'24h', buyKeys:['count_VOL_minute_1440_buy','vol_buy_24JAM','vol_buy_24h'], sellKeys:['count_VOL_minute_1440_sell','vol_sell_24JAM','vol_sell_24h'], avgKeys:['avg_VOLCOIN_buy_24JAM']}
                        ];

                        const tfRows = [];
                        const spikes = [];
                        for (const t of tfs) {
                            const b = getNumeric(data, ...t.buyKeys);
                            const s = getNumeric(data, ...t.sellKeys);
                            const a = getNumeric(data, ...t.avgKeys);
                            const ratio = a > 0 ? (b / a) : (s>0 ? (b / (s||1)) : 0);
                            const buyShare = (b + s) > 0 ? Math.round((b / (b + s)) * 100) : 0;
                            tfRows.push({k: t.k, buy: b, sell: s, avg: a, buyShare, ratio});
                            if (a > 0 && b / a >= 2) spikes.push({k: t.k, ratio: b / a, buy: b, avg: a});
                        }
                        spikes.sort((x,y)=>y.ratio-x.ratio);

                        // build HTML
                        let tfTable = '<table class="table table-sm text-light"><thead><tr><th>TF</th><th>Buy</th><th>Sell</th><th>Avg</th><th>Buy %</th><th>Vol/Avg</th></tr></thead><tbody>';
                        for (const r of tfRows) tfTable += `<tr><td>${r.k}</td><td>${r.buy}</td><td>${r.sell}</td><td>${r.avg}</td><td>${r.buyShare}%</td><td>${r.avg>0? (r.buy/r.avg).toFixed(2)+'x':'-'}</td></tr>`;
                        tfTable += '</tbody></table>';

                        const topSpikeHtml = spikes.length>0 ? `<div class="mb-2"><strong>Top Spike:</strong> ${spikes[0].k} â€” ${spikes[0].ratio.toFixed(2)}x (buy ${spikes[0].buy} vs avg ${spikes[0].avg})</div>` : '<div class="mb-2 text-muted">No significant spikes (vol >= 2x avg)</div>';

                        pane.innerHTML = `
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <div><h4 class="mb-0">ğŸ” ${coin} â€” Insight</h4><small class="text-muted">Last update: ${data.update_time || data.update_time_VOLCOIN || '-'}</small></div>
                                <div class="text-end"><small>Price: ${data.last||0} â€¢ Change: ${data.percent_change||0}%</small><div class="mt-1"><strong>Recommendation:</strong> ${rec.recommendation || 'N/A'} (${rec.confidence || 0}%)</div></div>
                            </div>
                            <div class="mb-3">${drawSparkline(hist, 760, 100)}</div>
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <h6>Metrics</h6>
                                    <p><strong>Risk:</strong> ${risk}%</p>
                                    <p><strong>Price Pos:</strong> ${pricePos}%</p>
                                    <p><strong>Vol Buy (2h):</strong> ${getNumeric(data,'count_VOL_minute_120_buy','vol_buy_2JAM')||0}</p>
                                    <p><strong>Vol Sell (2h):</strong> ${getNumeric(data,'count_VOL_minute_120_sell','vol_sell_2JAM')||0}</p>
                                    <p><strong>Buy z-score (2h):</strong> ${data._analytics && data._analytics.zScoreBuy2h !== undefined ? data._analytics.zScoreBuy2h : 'N/A'}</p>
                                    <p><strong>Sell z-score (2h):</strong> ${data._analytics && data._analytics.zScoreSell2h !== undefined ? data._analytics.zScoreSell2h : 'N/A'}</p>
                                    <p><strong>Persistence (last3 buys > mean+std):</strong> ${data._analytics && data._analytics.persistenceBuy3 !== undefined ? data._analytics.persistenceBuy3 : '-'}</p>
                                    ${data._analytics && data._analytics.divergence ? `<p class="text-warning"><strong>Divergence:</strong> ${data._analytics.divergence}</p>` : ''}
                                    ${data._analytics && data._analytics.sharpInsights ? `<p><strong>Insight:</strong><br/>${data._analytics.sharpInsights.map(s=>`- ${s}`).join('<br/>')}</p>` : ''}
                                </div>
                                <div class="col-md-4">
                                    <h6>Recommendation Breakdown</h6>
                                    <p>Score: ${rec.score !== undefined ? rec.score.toFixed(2) : '0.00'} â€¢ Confidence: ${rec.confidence || 0}%</p>
                                    <div class="progress mb-2" style="height:10px"><div class="progress-bar bg-success" role="progressbar" style="width:${rec.score>0?rec.confidence:0}%"></div><div class="progress-bar bg-danger" role="progressbar" style="width:${rec.score<0?rec.confidence:0}%"></div></div>
                                    ${topSpikeHtml}
                                </div>
                                <div class="col-md-4">
                                    <h6>Components</h6>
                                    <ul>
                                        <li>Imbalance: ${Number(comp.imbalance || 0).toFixed(2)}</li>
                                        <li>Deviation: ${Number(comp.deviation || 0).toFixed(2)}</li>
                                        <li>Price Move: ${Number(comp.priceMove || 0).toFixed(2)}</li>
                                        <li>Liquidity: ${Number(comp.liquidity || 0).toFixed(2)}</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="mb-3"><h6>Timeframe Comparison</h6>${tfTable}</div>
                            <div class="mb-3"><h6>Raw Data</h6><div class="d-flex gap-2"><button class="btn btn-outline-primary btn-sm" id="insightCopyJson">Copy JSON</button><button class="btn btn-outline-secondary btn-sm" id="insightExportJsonPane">Export JSON</button><button class="btn btn-outline-success btn-sm" id="insightExportCsvPane">Export CSV</button></div><pre id="insightRaw" style="max-height:200px;overflow:auto;margin-top:8px;background:#0b1220;padding:8px;border-radius:6px;color:#9ca3af;">${JSON.stringify(data,null,2)}</pre></div>
                        `;

                        document.getElementById('insightCopyJson').onclick = function() {
                            try { navigator.clipboard.writeText(JSON.stringify(data,null,2)); } catch(e) { window.__displayError('Clipboard copy failed'); }
                        };
                        document.getElementById('insightExportJsonPane').onclick = () => window.exportInsightJSON(coin, data);
                        document.getElementById('insightExportCsvPane').onclick = () => window.exportInsightCSV(coin, data);

                        // activate the tab
                        try {
                            const tabEl = document.getElementById('insight-tab');
                            if (tabEl) tabEl.click();
                        } catch (e) { console.warn('Could not activate insight tab', e); }

                        // Also set the summary coin filter to this coin and refresh table
                        try {
                            const filterEl = document.getElementById('coinFilter_summary');
                            if (filterEl) {
                                filterEl.value = coin;
                                // trigger input handlers (if any) and refresh table
                                try { filterEl.dispatchEvent(new Event('input')); } catch(e){}
                                try { if (typeof scheduleUpdateTable === 'function') scheduleUpdateTable(); } catch(e){}
                            }
                        } catch(e) { console.warn('Could not set summary filter for insight tab', e); }
                    } catch (e) { console.error('showInsightTab error', e); window.__displayError(e); }
                };

        // Object to store data by coin
        const coinDataMap = {};

        // Delegated click handler: ensure clicks anywhere in a summary row open the insight tab.
        try {
            const summaryBodyEl = document.getElementById('summaryBody');
            if (summaryBodyEl) {
                summaryBodyEl.addEventListener('click', (ev) => {
                    try {
                        const tr = ev.target.closest && ev.target.closest('tr');
                        if (!tr) return;
                        const coin = tr.dataset && tr.dataset.coin ? tr.dataset.coin : (tr.cells && tr.cells[0] ? tr.cells[0].textContent.trim() : null);
                        if (!coin) return;
                        const data = coinDataMap[coin] || null;
                        // If data is present, show insight tab; otherwise try fallback
                        showInsightTab(coin, data || {});
                    } catch (e) { /* swallow */ }
                }, { passive: true });
            }
        } catch (e) { console.warn('Delegated click wiring failed', e); }

        // Lightweight debug click logger: when clicking inside the summary table area,
        // log the actual event.target and the element at the click coordinates (elementFromPoint).
        // This helps detect invisible overlays or other elements intercepting clicks.
        try {
            document.addEventListener('click', function _dbgClickLogger(ev) {
                try {
                    const summaryEl = document.getElementById('summaryBody');
                    if (!summaryEl) return;
                    const rect = summaryEl.getBoundingClientRect();
                    // only log clicks that occur within the bounding box of the summary table
                    if (ev.clientX >= rect.left && ev.clientX <= rect.right && ev.clientY >= rect.top && ev.clientY <= rect.bottom) {
                        const target = ev.target;
                        const atPoint = document.elementFromPoint(ev.clientX, ev.clientY);
                        // Log useful identifying info
                        console.log('[DBG_CLICK] client:', ev.clientX, ev.clientY, 'target:', target, 'tag:', target.tagName, 'classes:', target.className);
                        console.log('[DBG_CLICK] elementFromPoint:', atPoint, 'tag:', atPoint && atPoint.tagName, 'classes:', atPoint && atPoint.className);
                        // If elementFromPoint is not contained inside the summary table, warn
                        if (atPoint && !summaryEl.contains(atPoint)) {
                            console.warn('[DBG_CLICK] Click inside summary bounds but top element is outside summary â€” possible overlay blocking clicks', atPoint);
                        }
                    }
                } catch (e) { /* swallow */ }
            }, true);
        } catch (e) { /* ignore in old browsers */ }
        // track which coins we've logged (to avoid noisy logs)
        const loggedCoins = new Set();
        const eventWatchBuffer = window._eventWatchBuffer || (window._eventWatchBuffer = []);

        function onWsOpen() {
            console.log("WebSocket connected.");
            try { const el = document.getElementById('loading'); if (el) el.style.display = 'none'; } catch(e){}
        }

        function onWsMessage(event) {
            const raw = JSON.parse(event.data);
            const coin = raw.coin; // Extract the coin from data
            // store last raw message and coin for UI inspection
            try { window._lastWsRaw = raw; window._lastReceivedCoin = coin; } catch(e){}
            if (!coin) return; // If there's no coin, skip

            // Debug: log keys and 24h-related fields once per coin (helps find naming mismatches)
            if (!loggedCoins.has(coin)) {
                try {
                    // console.log('[WS] Received keys for', coin, Object.keys(raw));
                } catch (e) { console.error('Logging error', e); }
                loggedCoins.add(coin);
            }

            // Keep only fields that are used by the table to reduce noise
            const keep = [
                // core
                'coin','last','percent_change','open','previous','high','low','update_time','update_time_VOLCOIN',
                // percent/durability fields (various names)
                'percent_vol_buy_1min','percent_vol_buy_5min','percent_vol_buy_10min','percent_vol_buy_15min','percent_vol_buy_20min','percent_vol_buy_30min','percent_vol_buy_60min','percent_vol_buy_120min',
                'percent_vol_sell_1min','percent_vol_sell_5min','percent_vol_sell_10min','percent_vol_sell_15min','percent_vol_sell_20min','percent_vol_sell_30min','percent_vol_sell_60min','percent_vol_sell_120min',
                'percent_sum_VOL_minute_120_buy','percent_sum_VOL_overall_buy',
                // 2h / 120min totals
                'count_VOL_minute_120_buy','count_VOL_minute_120_sell','vol_buy_2JAM','vol_sell_2JAM','vol_buy_120MENIT','vol_sell_120MENIT',
                // 24h
                'count_VOL_minute_1440_buy','count_VOL_minute_1440_sell','vol_buy_24JAM','vol_sell_24JAM','vol_buy_24jam','vol_sell_24jam','vol_buy_24h','vol_sell_24h','total_vol','total_vol_fiat',
                // smaller timeframes (1m,5m,10m,15m,20m,30m,60m)
                'vol_buy_1MENIT','vol_sell_1MENIT','vol_buy_5MENIT','vol_sell_5MENIT','vol_buy_10MENIT','vol_sell_10MENIT','vol_buy_15MENIT','vol_sell_15MENIT','vol_buy_20MENIT','vol_sell_20MENIT','vol_buy_30MENIT','vol_sell_30MENIT','vol_buy_1JAM','vol_sell_1JAM',
                // averages for timeframes
                'avg_VOLCOIN_buy_1MENIT','avg_VOLCOIN_sell_1MENIT','avg_VOLCOIN_buy_5MENIT','avg_VOLCOIN_sell_5MENIT','avg_VOLCOIN_buy_10MENIT','avg_VOLCOIN_sell_10MENIT','avg_VOLCOIN_buy_15MENIT','avg_VOLCOIN_sell_15MENIT','avg_VOLCOIN_buy_20MENIT','avg_VOLCOIN_sell_20MENIT','avg_VOLCOIN_buy_30MENIT','avg_VOLCOIN_sell_30MENIT','avg_VOLCOIN_buy_1JAM','avg_VOLCOIN_sell_1JAM','avg_VOLCOIN_buy_2JAM','avg_VOLCOIN_sell_2JAM','avg_VOLCOIN_buy_24JAM','avg_VOLCOIN_sell_24JAM'
            ];

            const data = {};
            for (const k of keep) {
                if (raw[k] !== undefined) data[k] = raw[k];
                // also try lowercase variants
                else if (raw[k.toLowerCase()] !== undefined) data[k] = raw[k.toLowerCase()];
            }
            // always keep coin
            data.coin = coin;

            // Compute client-side analytics (risk, ratios, deviation) for recent payload
            function computeAnalytics(p) {
                const toNum = (v) => {
                    if (v === undefined || v === null) return 0;
                    if (typeof v === 'number') return v;
                    const s = String(v).replace(/,/g, '');
                    const n = Number(s);
                    return isNaN(n) ? 0 : n;
                };

                const out = {};
                out.volBuy2h = toNum(p.count_VOL_minute_120_buy) || toNum(p.vol_buy_2JAM) || toNum(p.vol_buy_120MENIT) || toNum(p.vol_buy_2jam);
                out.volSell2h = toNum(p.count_VOL_minute_120_sell) || toNum(p.vol_sell_2JAM) || toNum(p.vol_sell_120MENIT) || toNum(p.vol_sell_2jam);
                out.total2h = out.volBuy2h + out.volSell2h;
                out.volRatioBuySell_percent = out.volSell2h > 0 ? (out.volBuy2h / out.volSell2h) * 100 : (out.volBuy2h > 0 ? 999 : 0);
                out.volDurability2h_percent = out.total2h > 0 ? (out.volBuy2h / out.total2h) * 100 : 0;

                out.avgBuy2h = toNum(p.avg_VOLCOIN_buy_2JAM) || toNum(p.avg_VOLCOIN_buy_2HOUR) || toNum(p.avg_VOLCOIN_buy_2jam) || toNum(p.avg_VOLCOIN_buy_120MENIT);
                out.avgSell2h = toNum(p.avg_VOLCOIN_sell_2JAM) || toNum(p.avg_VOLCOIN_sell_2HOUR) || toNum(p.avg_VOLCOIN_sell_2jam) || toNum(p.avg_VOLCOIN_sell_120MENIT);
                out.volBuy_vs_avg_percent = out.avgBuy2h > 0 ? (out.volBuy2h / out.avgBuy2h) * 100 : (out.volBuy2h > 0 ? 999 : 0);
                out.volSell_vs_avg_percent = out.avgSell2h > 0 ? (out.volSell2h / out.avgSell2h) * 100 : (out.volSell2h > 0 ? 999 : 0);

                // Frequency metrics (number of trades) â€” robust field lookup across variants
                out.freqBuy2h = toNum(p.count_FREQ_minute_120_buy) || toNum(p.freq_buy_2JAM) || toNum(p.freq_buy_120) || 0;
                out.freqSell2h = toNum(p.count_FREQ_minute_120_sell) || toNum(p.freq_sell_2JAM) || toNum(p.freq_sell_120) || 0;
                out.avgFreqBuy2h = toNum(p.avg_FREQCOIN_buy_2JAM) || toNum(p.avg_FREQCOIN_buy_120) || 0;
                out.avgFreqSell2h = toNum(p.avg_FREQCOIN_sell_2JAM) || toNum(p.avg_FREQCOIN_sell_120) || 0;
                out.freqBuy_vs_avg_percent = out.avgFreqBuy2h > 0 ? (out.freqBuy2h / out.avgFreqBuy2h) * 100 : (out.freqBuy2h > 0 ? 999 : 0);
                out.freqSell_vs_avg_percent = out.avgFreqSell2h > 0 ? (out.freqSell2h / out.avgFreqSell2h) * 100 : (out.freqSell2h > 0 ? 999 : 0);

                // Use coin-only totals (ignore fiat). total_vol is coin amount (sum of trades)
                const totalVol = toNum(p.total_vol) || (out.total2h || 0);
                out.liquidity_avg_trade_value = totalVol; // use coin-only total as liquidity proxy

                // Simple rule-based risk scoring (0 low - 100 high)
                const comp = {};
                comp.imbalance = Math.abs(50 - out.volDurability2h_percent) * 0.8; // up to ~40
                const devBuy = out.avgBuy2h > 0 ? Math.max(0, 50 - out.volBuy_vs_avg_percent) : 0;
                const devSell = out.avgSell2h > 0 ? Math.max(0, 50 - out.volSell_vs_avg_percent) : 0;
                comp.deviation = Math.max(devBuy, devSell) * 0.5;
                const pctChange = toNum(p.percent_change) || ((toNum(p.last) && toNum(p.previous)) ? ((toNum(p.last) - toNum(p.previous)) / toNum(p.previous)) * 100 : 0);
                comp.priceMove = Math.min(30, Math.abs(pctChange) * 2);
                comp.liquidity = out.liquidity_avg_trade_value > 0 ? Math.max(0, 20 - Math.log10(out.liquidity_avg_trade_value + 1) * 4) : 10;
                const riskScore = Math.min(100, comp.imbalance + comp.deviation + comp.priceMove + comp.liquidity);
                out.riskScore = Math.round(riskScore);
                out.components = comp;
                return out;
            }

            // attach analytics and maintain short history for sparkline and z-scores
            try {
                data._analytics = computeAnalytics(data);
                data.risk_score = data._analytics.riskScore;
                // keep history; prefer persisted history when available
                if (!data._history || !Array.isArray(data._history) || data._history.length === 0) {
                    // try load persisted
                    const persisted = persistHistoryEnabled ? loadPersistedHistory(coin) : [];
                    data._history = (persisted && persisted.length > 0) ? persisted.slice(-MAX_HISTORY) : [];
                }
                // include frequency fields in persisted history so z-scores can be computed later
                data._history.push({ ts: Date.now(), volBuy2h: data._analytics.volBuy2h || 0, volSell2h: data._analytics.volSell2h || 0, freqBuy2h: data._analytics.freqBuy2h || 0, freqSell2h: data._analytics.freqSell2h || 0, price: data.last || 0 });
                if (data._history.length > MAX_HISTORY) data._history = data._history.slice(-MAX_HISTORY);
                // save (throttled)
                try { savePersistedHistory(coin, data._history); } catch(e) {}

                    // --- Additional sharp insights (z-scores, persistence, divergence) ---
                try {
                    const hist = data._history.map(h => ({buy: Number(h.volBuy2h||0), sell: Number(h.volSell2h||0), freqBuy: Number(h.freqBuy2h||0), freqSell: Number(h.freqSell2h||0), price: Number(h.price||0)}));
                    function meanStd(arr) {
                        if (!arr || arr.length === 0) return {mean:0, std:0};
                        const m = arr.reduce((s,v)=>s+v,0)/arr.length;
                        const varr = arr.reduce((s,v)=>s+Math.pow(v-m,2),0)/arr.length;
                        return { mean: m, std: Math.sqrt(varr) };
                    }
                    const buySeries = hist.map(h=>h.buy);
                    const sellSeries = hist.map(h=>h.sell);
                    const freqBuySeries = hist.map(h=>h.freqBuy);
                    const freqSellSeries = hist.map(h=>h.freqSell);
                    const buyStat = meanStd(buySeries);
                    const sellStat = meanStd(sellSeries);
                    const freqBuyStat = meanStd(freqBuySeries);
                    const freqSellStat = meanStd(freqSellSeries);
                    const currBuy = data._analytics.volBuy2h || 0;
                    const currSell = data._analytics.volSell2h || 0;
                    const currFreqBuy = data._analytics.freqBuy2h || 0;
                    const currFreqSell = data._analytics.freqSell2h || 0;

                    // require a minimum number of samples and non-zero std to compute z-scores
                    const MIN_SAMPLES_FOR_Z = 6;
                    let zBuy = null, zSell = null, zFreqBuy = null, zFreqSell = null;
                    if (buySeries.length >= MIN_SAMPLES_FOR_Z && buyStat.std > 0) {
                        zBuy = (currBuy - buyStat.mean) / buyStat.std;
                    }
                    if (sellSeries.length >= MIN_SAMPLES_FOR_Z && sellStat.std > 0) {
                        zSell = (currSell - sellStat.mean) / sellStat.std;
                    }
                    if (freqBuySeries.length >= MIN_SAMPLES_FOR_Z && freqBuyStat.std > 0) {
                        zFreqBuy = (currFreqBuy - freqBuyStat.mean) / freqBuyStat.std;
                    }
                    if (freqSellSeries.length >= MIN_SAMPLES_FOR_Z && freqSellStat.std > 0) {
                        zFreqSell = (currFreqSell - freqSellStat.mean) / freqSellStat.std;
                    }

                    // persistence: count of last 3 points where buy > mean+std, only when stats meaningful
                    const lastN = 3;
                    let persistBuy = null, persistFreqBuy = null;
                    if (buySeries.length >= lastN && buyStat.std > 0) {
                        const recent = buySeries.slice(Math.max(0, buySeries.length - lastN));
                        persistBuy = recent.filter(v => v > (buyStat.mean + buyStat.std)).length;
                    }
                    if (freqBuySeries.length >= lastN && freqBuyStat.std > 0) {
                        const recentF = freqBuySeries.slice(Math.max(0, freqBuySeries.length - lastN));
                        persistFreqBuy = recentF.filter(v => v > (freqBuyStat.mean + freqBuyStat.std)).length;
                    }

                    // divergence: price down but buy durability high
                    const pctChange = Number(data.percent_change) || (data.last && data.previous ? ((Number(data.last)-Number(data.previous))/Number(data.previous))*100 : 0);
                    const volDur2h = data._analytics.volDurability2h_percent || 0;
                    let divergence = null;
                    if (pctChange < -0.5 && volDur2h >= 60 && zBuy > 1) divergence = 'Bullish divergence: price down while buy durability & volume surge';
                    else if (pctChange > 0.5 && volDur2h <= 40 && zSell > 1) divergence = 'Bearish divergence: price up but sell pressure increasing';

                    data._analytics.zScoreBuy2h = (zBuy === null || zBuy === undefined) ? undefined : Number(zBuy.toFixed(2));
                    data._analytics.zScoreSell2h = (zSell === null || zSell === undefined) ? undefined : Number(zSell.toFixed(2));
                    data._analytics.zScoreFreqBuy2h = (zFreqBuy === null || zFreqBuy === undefined) ? undefined : Number(zFreqBuy.toFixed(2));
                    data._analytics.zScoreFreqSell2h = (zFreqSell === null || zFreqSell === undefined) ? undefined : Number(zFreqSell.toFixed(2));
                    data._analytics.persistenceBuy3 = (persistBuy === null || persistBuy === undefined) ? undefined : persistBuy; // 0..3 or undefined
                    data._analytics.persistenceFreqBuy3 = (persistFreqBuy === null || persistFreqBuy === undefined) ? undefined : persistFreqBuy;
                    data._analytics.divergence = divergence;

                    // sharp insight summary
                    let sharp = [];
                    if (zBuy >= 2 && persistBuy >= 2) sharp.push('Strong buy momentum (z>=2 & persistent)');
                    if (zFreqBuy >= 2 && persistFreqBuy >= 2) sharp.push('Strong trade-frequency surge (freq z>=2 & persistent)');
                    if (zBuy >= 1.5 && volDur2h >= 60) sharp.push('Elevated buy interest vs history');
                    if (divergence) sharp.push(divergence);
                    if (sharp.length === 0) sharp.push('No strong anomalies detected');
                    data._analytics.sharpInsights = sharp;
                    const meaningful = sharp.filter(s => s && !/No strong anomalies detected/i.test(s));
                    try {
                        if (meaningful.length > 0) {
                            eventWatchBuffer.push({ ts: Date.now(), coin, type: 'insight', messages: meaningful.slice(0, 3) });
                            if (eventWatchBuffer.length > 200) eventWatchBuffer.splice(0, eventWatchBuffer.length - 200);
                        }
                    } catch (e) { console.warn('event buffer push failed', e); }
                    // trigger alert if sharp insights are meaningful
                    try {
                        if (meaningful.length > 0) {
                            const now = Date.now();
                            const last = lastAlertAt[coin] || 0;
                            // throttle per coin: 60s
                            if (now - last > 60*1000) {
                                lastAlertAt[coin] = now;
                                const title = `${coin} â€” Alert`;
                                const msg = meaningful.join(' â€¢ ');
                                showAlertBanner(title, msg, 'warning', 10000);
                                // send webhook if configured
                                sendAlertWebhook(coin, { insights: meaningful, ts: now });
                            }
                        }
                    } catch(e) { console.warn('alert trigger error', e); }
                } catch(e) { console.error('analytics extras error', e); }

            } catch(e){ data._analytics = {}; data.risk_score = 0; }

            // Derive percent_sum_VOL_* fields from volume / avg if backend didn't provide them.
            // local numeric getter (robust to multiple key names)
            function localGetNumeric(obj, ...keys) {
                if (!obj) return 0;
                const lower = {};
                for (const kk in obj) {
                    try { lower[kk.toLowerCase()] = obj[kk]; } catch (e) {}
                }
                for (const key of keys) {
                    if (!key) continue;
                    if (obj[key] !== undefined && obj[key] !== null) {
                        const v = obj[key];
                        const n = Number(typeof v === 'string' ? v.replace(/,/g, '') : v);
                        if (!isNaN(n)) return n;
                    }
                    const lk = key.toLowerCase();
                    if (lower[lk] !== undefined && lower[lk] !== null) {
                        const v = lower[lk];
                        const n = Number(typeof v === 'string' ? v.replace(/,/g, '') : v);
                        if (!isNaN(n)) return n;
                    }
                }
                return 0;
            }

            const timeframeMap = [
                { pctKey: 'percent_sum_VOL_minute1_buy', volKeys: ['count_VOL_minute1_buy','vol_buy_1MENIT','vol_buy_1m'], avgKeys: ['avg_VOLCOIN_buy_1MENIT'] },
                { pctKey: 'percent_sum_VOL_minute_5_buy', volKeys: ['count_VOL_minute_5_buy','vol_buy_5MENIT','vol_buy_5m'], avgKeys: ['avg_VOLCOIN_buy_5MENIT'] },
                { pctKey: 'percent_sum_VOL_minute_10_buy', volKeys: ['count_VOL_minute_10_buy','vol_buy_10MENIT','vol_buy_10m'], avgKeys: ['avg_VOLCOIN_buy_10MENIT'] },
                { pctKey: 'percent_sum_VOL_minute_15_buy', volKeys: ['count_VOL_minute_15_buy','vol_buy_15MENIT','vol_buy_15m'], avgKeys: ['avg_VOLCOIN_buy_15MENIT'] },
                { pctKey: 'percent_sum_VOL_minute_20_buy', volKeys: ['count_VOL_minute_20_buy','vol_buy_20MENIT','vol_buy_20m'], avgKeys: ['avg_VOLCOIN_buy_20MENIT'] },
                { pctKey: 'percent_sum_VOL_minute_30_buy', volKeys: ['count_VOL_minute_30_buy','vol_buy_30MENIT','vol_buy_30m'], avgKeys: ['avg_VOLCOIN_buy_30MENIT'] },
                { pctKey: 'percent_sum_VOL_minute_60_buy', volKeys: ['count_VOL_minute_60_buy','vol_buy_1JAM','vol_buy_60MENIT'], avgKeys: ['avg_VOLCOIN_buy_1JAM','avg_VOLCOIN_buy_60MENIT'] },
                { pctKey: 'percent_sum_VOL_minute_120_buy', volKeys: ['count_VOL_minute_120_buy','vol_buy_2JAM','vol_buy_120MENIT'], avgKeys: ['avg_VOLCOIN_buy_2JAM','avg_VOLCOIN_buy_120MENIT'] },
                { pctKey: 'percent_sum_VOL_overall_buy', volKeys: ['count_VOL_minute_1440_buy','vol_buy_24JAM','vol_buy_24h'], avgKeys: ['avg_VOLCOIN_buy_24JAM'] }
            ];

            for (const tf of timeframeMap) {
                // if backend already provided a value, skip
                if (data[tf.pctKey] !== undefined && data[tf.pctKey] !== null) continue;
                const volBuy = localGetNumeric(data, ...tf.volKeys);
                const avgBuy = localGetNumeric(data, ...tf.avgKeys);
                // If avg present and >0, compute vol/avg*100; else fallback to buy/(buy+sell)*100 when possible
                let pct = 0;
                if (avgBuy > 0) {
                    pct = Math.round((volBuy / avgBuy) * 100);
                } else {
                    // try compute by proportion of buy vs total
                    const volSellKeyGuess = tf.volKeys.map(k => k.replace(/buy/i,'sell'));
                    const volSell = localGetNumeric(data, ...volSellKeyGuess, 'count_VOL_minute_120_sell');
                    const total = (volBuy || 0) + (volSell || 0);
                    pct = total > 0 ? Math.round((volBuy / total) * 100) : 0;
                }
                data[tf.pctKey] = pct;
            }

            // Store sanitized data by coin
            coinDataMap[coin] = data;

            // Evaluate alert rules for this incoming data (non-blocking)
            try { if (typeof evaluateAlertRulesForData === 'function') evaluateAlertRulesForData(data); } catch(e) { console.warn('evaluateAlertRules call failed', e); }

            scheduleUpdateTable(); // Update table after receiving new data (debounced)
        };

        // onclose/onerror are handled when a socket is (re)created via attachHandlers

        // Function to update table based on filter, row limit, and sort order
        // Helper: robust numeric getter (try multiple key variants and normalize strings)
        function getNumeric(data, ...keys) {
            if (!data) return 0;
            // build lowercase map for fallback
            const lower = {};
            for (const k in data) {
                try {
                    lower[k.toLowerCase()] = data[k];
                } catch (e) {}
            }

            for (const key of keys) {
                if (!key) continue;
                // try exact
                if (data[key] !== undefined && data[key] !== null) {
                    const v = data[key];
                    const n = Number(typeof v === 'string' ? v.replace(/,/g, '') : v);
                    if (!isNaN(n)) return n;
                }
                // try lowercase variant
                const lk = key.toLowerCase();
                if (lower[lk] !== undefined && lower[lk] !== null) {
                    const v = lower[lk];
                    const n = Number(typeof v === 'string' ? v.replace(/,/g, '') : v);
                    if (!isNaN(n)) return n;
                }
            }
            return 0;
        }

        // Recommendation engine: normalized, z-score aware, with per-coin cooldown and logging
        const RECOMMENDATION_COOLDOWN_MS = 120000; // 2 minutes cooldown to avoid flip-flopping
        const RECOMMENDATION_THRESHOLD = 0.30; // absolute score threshold to emit BUY/SELL
        const recommendationCooldowns = window._recommendationCooldowns || (window._recommendationCooldowns = {});

        function _tanh(x){ if (Math.tanh) return Math.tanh(x); const e = Math.exp(2*x); return (e-1)/(e+1); }

        // Compute a simple ATR-like measure (average absolute change) from history
        function computeATR(history, periods = 14) {
            try {
                if (!history || !Array.isArray(history) || history.length < 2) return 0;
                const arr = history.slice(-Math.max(periods, 2));
                let sum = 0;
                let count = 0;
                for (let i = 1; i < arr.length; i++) {
                    const p0 = Number(arr[i-1].price) || Number(arr[i-1].last) || 0;
                    const p1 = Number(arr[i].price) || Number(arr[i].last) || 0;
                    if (p0 > 0 && p1 > 0) {
                        sum += Math.abs(p1 - p0);
                        count++;
                    }
                }
                return count > 0 ? (sum / count) : 0;
            } catch (e) { return 0; }
        }

        function calculateRecommendation(data, pricePosition, timeframe, applyState = false) {
            if (!data) {
                return { recommendation: 'HOLD', confidence: 0, className: 'recommendation-hold', score: 0 };
            }
            // Extract analytics and fallbacks
            const a = data._analytics || {};
            // Default 2h and 24h fields
            const volDur2h = a.volDurability2h_percent ?? getNumeric(data, 'percent_sum_VOL_minute_120_buy', 'percent_vol_buy_120min', 'percent_vol_buy_2jam');
            const volDur24h = a.volDurability24h_percent ?? getNumeric(data, 'percent_sum_VOL_overall_buy', 'percent_vol_buy_24h');
            const volBuy2h = a.volBuy2h ?? getNumeric(data, 'count_VOL_minute_120_buy', 'vol_buy_2JAM', 'vol_buy_120MENIT', 'vol_buy_2jam');
            const volSell2h = a.volSell2h ?? getNumeric(data, 'count_VOL_minute_120_sell', 'vol_sell_2JAM', 'vol_sell_120MENIT', 'vol_sell_2jam');
            const zBuy = a.zScoreBuy2h ?? 0;
            const zSell = a.zScoreSell2h ?? 0;
            const persistenceBuy3 = a.persistenceBuy3 ?? 0;
            const divergence = a.divergence ?? 0;
            const riskScore = a.riskScore ?? 0;

            // If a specific timeframe is requested, override volume-based signals with that timeframe
            let volDurTf = null, volBuyTf = null, volSellTf = null, zImbalanceTf = null;
            try {
                if (timeframe) {
                    const map = {
                        '1m':  { volKey: 'percent_sum_VOL_minute1_buy', buyKey: 'count_VOL_minute1_buy', sellKey: 'count_VOL_minute1_sell' },
                        '5m':  { volKey: 'percent_sum_VOL_minute_5_buy', buyKey: 'count_VOL_minute_5_buy', sellKey: 'count_VOL_minute_5_sell' },
                        '10m': { volKey: 'percent_sum_VOL_minute_10_buy', buyKey: 'count_VOL_minute_10_buy', sellKey: 'count_VOL_minute_10_sell' },
                        '30m': { volKey: 'percent_sum_VOL_minute_30_buy', buyKey: 'count_VOL_minute_30_buy', sellKey: 'count_VOL_minute_30_sell' },
                        '60m': { volKey: 'percent_sum_VOL_minute_60_buy', buyKey: 'count_VOL_minute_60_buy', sellKey: 'count_VOL_minute_60_sell' },
                        '120m':{ volKey: 'percent_sum_VOL_minute_120_buy', buyKey: 'count_VOL_minute_120_buy', sellKey: 'count_VOL_minute_120_sell' },
                        '24h': { volKey: 'percent_sum_VOL_overall_buy', buyKey: 'count_VOL_minute_1440_buy', sellKey: 'count_VOL_minute_1440_sell' }
                    };
                    const info = map[String(timeframe)] || null;
                    if (info) {
                        volBuyTf = getNumeric(data, info.buyKey) || 0;
                        volSellTf = getNumeric(data, info.sellKey) || 0;
                        volDurTf = getNumeric(data, info.volKey) || (volBuyTf + volSellTf > 0 ? Math.round((volBuyTf / (volBuyTf + volSellTf)) * 100) : null);
                        zImbalanceTf = _tanh(((volBuyTf || 0) - (volSellTf || 0)) / Math.max((volBuyTf || 0) + (volSellTf || 0), 1));
                    }
                }
            } catch (e) { /* ignore timeframe mapping errors */ }

            // Normalized feature construction (all in [-1,1])
            const priceBias = (50 - (Number(pricePosition) || 50)) / 50; // 1 => strong buy bias, -1 => strong sell bias
            const volDurNorm = ((Number(volDurTf != null ? volDurTf : volDur2h) || 50) - 50) / 50; // positive => buy-dominant
            const vol24Norm = ((Number(volDur24h) || 50) - 50) / 50;
            // Use z-scores when available; map to [-1,1] via tanh scaling
            const zImbalance = (zImbalanceTf != null) ? zImbalanceTf : _tanh((Number(zBuy) - Number(zSell)) / 3); // >0 => buy pressure
            // Frequency imbalance: prefer z-scores if available, else ratio-derived
            const freqZBuy = (a && a.zScoreFreqBuy2h !== undefined) ? Number(a.zScoreFreqBuy2h) : 0;
            const freqZSell = (a && a.zScoreFreqSell2h !== undefined) ? Number(a.zScoreFreqSell2h) : 0;
            const freqImbalance = (freqZBuy || freqZSell) ? _tanh((freqZBuy - freqZSell) / 3) : _tanh((( (Number(a.freqBuy2h)||0) - (Number(a.freqSell2h)||0) ) / Math.max(((Number(a.freqBuy2h)||0)+(Number(a.freqSell2h)||0)),1)));
            const persistenceNorm = ((Number(persistenceBuy3) || 0) - 1.5) / 1.5; // approx -1..1
            const divergenceNorm = Math.max(-1, Math.min(1, (Number(divergence) || 0) / 10));
            const riskPenalty = Math.max(0, Math.min(1, (Number(riskScore) || 0) / 100));
            const factors = {
                priceBias,
                volDurNorm,
                vol24Norm,
                zImbalance,
                freqImbalance,
                persistenceNorm,
                divergenceNorm,
                riskPenalty
            };

            // Feature weights (tuned to prioritize imbalance & durability)
            const W = {
                price: 0.16,
                volDur: 0.18,
                imbalance: 0.30,
                freq: 0.20,
                persistence: 0.10,
                divergence: 0.06
            };

            // Raw signed score in [-1.5,1.5] roughly; then clamp to [-1,1]
            let rawScore = 0;
            rawScore += W.price * priceBias;
            rawScore += W.volDur * volDurNorm;
            rawScore += W.imbalance * zImbalance;
            rawScore += W.freq * freqImbalance;
            rawScore += W.persistence * persistenceNorm;
            rawScore += W.divergence * divergenceNorm;

            // Apply small risk penalty to reduce magnitude
            rawScore = rawScore * (1 - 0.5 * riskPenalty);
            const score = Math.max(-1, Math.min(1, rawScore));

            // Confidence: scale absolute score to 0..100 using smooth mapping
            const confidence = Math.round(Math.abs(score) * 100);

            // Determine recommendation label
            let recommendation = 'HOLD';
            if (score >= RECOMMENDATION_THRESHOLD) recommendation = 'BUY';
            else if (score <= -RECOMMENDATION_THRESHOLD) recommendation = 'SELL';

            // Per-coin cooldown and logging are optional side-effects triggered only when applyState===true
            const coin = data.coin || data.symbol || data.code || 'unknown';
            const className = recommendation === 'BUY' ? 'recommendation-buy' : (recommendation === 'SELL' ? 'recommendation-sell' : 'recommendation-hold');

            if (applyState) {
                const now = Date.now();
                const last = recommendationCooldowns[coin] || { ts: 0, rec: null };
                if (now - last.ts < RECOMMENDATION_COOLDOWN_MS && last.rec && last.rec !== recommendation) {
                    // During cooldown prefer HOLD rather than flip
                    recommendation = 'HOLD';
                }
                // Save cooldown info (if recommendation is non-HOLD, update timestamp and rec)
                if (recommendation !== 'HOLD') {
                    recommendationCooldowns[coin] = { ts: now, rec: recommendation };
                } else if (!recommendationCooldowns[coin]) {
                    recommendationCooldowns[coin] = { ts: 0, rec: null };
                }

                // Append to lightweight recommendation log on the data analytics object for later backtesting
                a.recommendationLog = a.recommendationLog || [];
                a.recommendationLog.push({
                    ts: now,
                    coin,
                    timeframe: timeframe || '120m',
                    price: Number(data.last) || 0,
                    score,
                    recommendation,
                    confidence,
                    priceBias,
                    volDur: volDurTf != null ? volDurTf : volDur2h,
                    volBuyTf,
                    volSellTf,
                    zImbalance,
                    persistenceNorm,
                    divergenceNorm,
                    riskScore,
                    factors
                });
                if (a.recommendationLog.length > 200) a.recommendationLog.shift();
            }

            return { recommendation, confidence, className, score, factors };
        }

        // Quick sort function for popular metrics
        function quickSort(criteria) {
            document.getElementById('sortBy').value = criteria;
            scheduleUpdateTable();
            
            // Show success message using Alerts tab banner instead of SweetAlert
            try {
                showAlertBanner('Sorted!', `Table sorted by ${criteria.replace('_', ' ').toUpperCase()}`, 'info', 1500);
            } catch (e) {
                console.log('Alert banner failed', e);
            }
        }

        function updateTable() {
            summaryBody.innerHTML = '';
            volBody.innerHTML = '';
            if (volRatioBody) volRatioBody.innerHTML = '';
            if (recsBody) recsBody.innerHTML = '';
            // clear Vol Dur table as well so row limit applies consistently
            const volDurBody = document.getElementById('volDurBody');
            if (volDurBody) volDurBody.innerHTML = '';
            if (spikeBody) spikeBody.innerHTML = '';
            const spikeRows = []; // collect spikes across coins

            const filterText = getActiveFilterValue();
            const sortBy = sortBySelect.value;
            const sortOrder = getSortOrderValue();
            // Debugging: log current sort selection (helps diagnose if change events fire)
            // try { console.debug && console.debug('updateTable sortBy=', sortBy, 'order=', sortOrder); } catch(e) {}
            let rowCount = 0;
            // count of rows inserted into the Recommendations table (separate from coin row count)
            let recsRowCount = 0;
            // flag to indicate we've filled the requested recs rows and can stop early
            let doneRecs = false;

            // Function to get sort value based on selected criteria
            function getSortValue(data, criteria) {
                // Helper: compute percent change from history when specific percent fields are missing
                function computeHistoryPercentChange(d, lookbackMs) {
                    try {
                        if (!d || !d._history || !Array.isArray(d._history) || d._history.length === 0) return 0;
                        const now = Date.now();
                        // If lookbackMs not provided, use full history range
                        if (!lookbackMs) {
                            const first = d._history[0];
                            const last = d._history[d._history.length - 1];
                            if (!first || !last || !first.price) return 0;
                            const p0 = Number(first.price) || 0;
                            const p1 = Number(last.price) || 0;
                            return p0 > 0 ? ((p1 - p0) / p0) * 100 : 0;
                        }
                        // Find the earliest point at or before now - lookbackMs
                        const cutoff = now - lookbackMs;
                        let point = null;
                        for (let i = d._history.length - 1; i >= 0; i--) {
                            if (d._history[i].ts <= cutoff) { point = d._history[i]; break; }
                        }
                        // if not found, use earliest
                        if (!point) point = d._history[0];
                        const last = d._history[d._history.length - 1];
                        const p0 = Number(point.price) || 0;
                        const p1 = Number(last.price) || 0;
                        return p0 > 0 ? ((p1 - p0) / p0) * 100 : 0;
                    } catch (e) { return 0; }
                }

                // Helper: parse lookback from criteria name (e.g., 'change_10sec_1' => 1s, 'change_5min_20' => 20min)
                function parseLookbackMs(name) {
                    try {
                        const re = /(\d+)(sec|min|jam|hour|m)/ig;
                        let match, lastMatch = null;
                        while ((match = re.exec(name)) !== null) { lastMatch = match; }
                        if (!lastMatch) {
                            // fallback: pick last number as minutes
                            const num = name.match(/(\d+)(?!.*\d)/);
                            if (num) return Number(num[0]) * 60 * 1000;
                            return null;
                        }
                        const val = Number(lastMatch[1]);
                        const unit = (lastMatch[2] || '').toLowerCase();
                        if (unit.startsWith('sec')) return val * 1000;
                        if (unit === 'min' || unit === 'm') return val * 60 * 1000;
                        if (unit === 'jam' || unit.startsWith('hour')) return val * 60 * 60 * 1000;
                        return val * 60 * 1000;
                    } catch (e) { return null; }
                }

                switch(criteria) {
                    // Durability
                    case 'vol_dur_2h':
                        return parseFloat(data.percent_sum_VOL_minute_120_buy) || 0;
                    case 'activity_dur_2h':
                        return getNumeric(data, 'sum_minute_120_buy', 'count_VOL_minute_120_buy') || 0;

                    // Price & Change
                    case 'change':
                        return parseFloat(data.percent_change) || 0;
                    case 'price':
                        return parseFloat(data.last) || 0;
                    case 'price_position':
                        const currentPrice = parseFloat(data.last) || 0;
                        const highPrice = parseFloat(data.high) || currentPrice;
                        const lowPrice = parseFloat(data.low) || currentPrice;
                        const priceRange = highPrice - lowPrice;
                        return priceRange > 0 ? ((currentPrice - lowPrice) / priceRange) * 100 : 50;
                    case 'recommendation':
                        try {
                            if (typeof calculateRecommendation === 'function') {
                                const rec = calculateRecommendation(data, 50, null, false); // Use pure mode for sorting
                                return rec && typeof rec.score === 'number' ? rec.score : 0; // Positive = Buy bias, Negative = Sell bias
                            }
                        } catch (err) {
                            console.error('calculateRecommendation threw when sorting:', err);
                        }
                        return 0;

    
                    // Volume 24h
                    case 'vol_buy_24h':
                        return parseFloat(data.count_VOL_minute_1440_buy) || 0;
                    case 'vol_sell_24h':
                        return parseFloat(data.count_VOL_minute_1440_sell) || 0;
                    case 'vol_total_24h':
                        return (parseFloat(data.count_VOL_minute_1440_buy) || 0) + (parseFloat(data.count_VOL_minute_1440_sell) || 0);
                    case 'avg_vol_buy_24h':
                        return parseFloat(data.avg_VOLCOIN_buy_24HOUR) || 0;
                    case 'avg_vol_sell_24h':
                        return parseFloat(data.avg_VOLCOIN_sell_24HOUR) || 0;
                    case 'avg_vol_buy_2h':
                        return parseFloat(data.avg_VOLCOIN_buy_2HOUR) || 0;
                    case 'avg_vol_sell_2h':
                        return parseFloat(data.avg_VOLCOIN_sell_2HOUR) || 0;

                    // Volume Ratio 2h
                    case 'vol_ratio_2h':
                        // Use robust getter (covers multiple backend field names) and fall back to computed analytics
                        const volBuy2h_v = getNumeric(data, 'count_VOL_minute_120_buy', 'vol_buy_2JAM', 'vol_buy_120MENIT', 'vol_buy_2jam') || ((data._analytics && Number(data._analytics.volBuy2h)) || 0);
                        const volSell2h_v = getNumeric(data, 'count_VOL_minute_120_sell', 'vol_sell_2JAM', 'vol_sell_120MENIT', 'vol_sell_2jam') || ((data._analytics && Number(data._analytics.volSell2h)) || 0);
                        return volSell2h_v > 0 ? (volBuy2h_v / volSell2h_v) * 100 : (volBuy2h_v > 0 ? 999 : 0);

    
                        
                    // Volume 1h
                    case 'vol_buy_1h':
                        return parseFloat(data.count_VOL_minute_60_buy) || 0;
                    case 'vol_sell_1h':
                        return parseFloat(data.count_VOL_minute_60_sell) || 0;
                    case 'vol_total_1h':
                        return (parseFloat(data.count_VOL_minute_60_buy) || 0) + (parseFloat(data.count_VOL_minute_60_sell) || 0);
                    case 'avg_vol_buy_1h':
                        return parseFloat(data.avg_VOLCOIN_buy_1HOUR) || 0;
                    case 'avg_vol_sell_1h':
                        return parseFloat(data.avg_VOLCOIN_sell_1HOUR) || 0;

 
                        
                    // Volume 10m
                    case 'vol_buy_10m':
                        return parseFloat(data.count_VOL_minute_10_buy) || 0;
                    case 'vol_sell_10m':
                        return parseFloat(data.count_VOL_minute_10_sell) || 0;
                    case 'vol_total_10m':
                        return (parseFloat(data.count_VOL_minute_10_buy) || 0) + (parseFloat(data.count_VOL_minute_10_sell) || 0);
                    case 'avg_vol_buy_10m':
                        return parseFloat(data.avg_VOLCOIN_buy_10MENIT) || 0;
                    case 'avg_vol_sell_10m':
                        return parseFloat(data.avg_VOLCOIN_sell_10MENIT) || 0;

      
                        
                    // Volume 5m
                    case 'vol_buy_5m':
                        return parseFloat(data.count_VOL_minute_5_buy) || 0;
                    case 'vol_sell_5m':
                        return parseFloat(data.count_VOL_minute_5_sell) || 0;
                    case 'vol_total_5m':
                        return (parseFloat(data.count_VOL_minute_5_buy) || 0) + (parseFloat(data.count_VOL_minute_5_sell) || 0);
                    case 'avg_vol_buy_5m':
                        return parseFloat(data.avg_VOLCOIN_buy_5MENIT) || 0;
                    case 'avg_vol_sell_5m':
                        return parseFloat(data.avg_VOLCOIN_sell_5MENIT) || 0;


                        
                    // Volume 30m
                    case 'vol_buy_30m':
                        return parseFloat(data.count_VOL_minute_30_buy) || 0;
                    case 'vol_sell_30m':
                        return parseFloat(data.count_VOL_minute_30_sell) || 0;
                    case 'vol_total_30m':
                        return (parseFloat(data.count_VOL_minute_30_buy) || 0) + (parseFloat(data.count_VOL_minute_30_sell) || 0);
                    case 'avg_vol_buy_30m':
                        return parseFloat(data.avg_VOLCOIN_buy_30MENIT) || 0;
                    case 'avg_vol_sell_30m':
                        return parseFloat(data.avg_VOLCOIN_sell_30MENIT) || 0;


                        
                    // Volume 20m
                    case 'vol_buy_20m':
                        return parseFloat(data.count_VOL_minute_20_buy) || 0;
                    case 'vol_sell_20m':
                        return parseFloat(data.count_VOL_minute_20_sell) || 0;
                    case 'vol_total_20m':
                        return (parseFloat(data.count_VOL_minute_20_buy) || 0) + (parseFloat(data.count_VOL_minute_20_sell) || 0);
                    case 'avg_vol_buy_20m':
                        return parseFloat(data.avg_VOLCOIN_buy_20MENIT) || 0;
                    case 'avg_vol_sell_20m':
                        return parseFloat(data.avg_VOLCOIN_sell_20MENIT) || 0;


                        
                    // Volume 15m
                    case 'vol_buy_15m':
                        return parseFloat(data.count_VOL_minute_15_buy) || 0;
                    case 'vol_sell_15m':
                        return parseFloat(data.count_VOL_minute_15_sell) || 0;
                    case 'vol_total_15m':
                        return (parseFloat(data.count_VOL_minute_15_buy) || 0) + (parseFloat(data.count_VOL_minute_15_sell) || 0);
                    case 'avg_vol_buy_15m':
                        return parseFloat(data.avg_VOLCOIN_buy_15MENIT) || 0;
                    case 'avg_vol_sell_15m':
                        return parseFloat(data.avg_VOLCOIN_sell_15MENIT) || 0;


                        
                    // Volume 1m
                    case 'vol_buy_1m':
                        return parseFloat(data.count_VOL_minute1_buy) || 0;
                    case 'vol_sell_1m':
                        return parseFloat(data.count_VOL_minute1_sell) || 0;
                    case 'vol_total_1m':
                        return (parseFloat(data.count_VOL_minute1_buy) || 0) + (parseFloat(data.count_VOL_minute1_sell) || 0);
                    case 'avg_vol_buy_1m':
                        return parseFloat(data.avg_VOLCOIN_buy_1MENIT) || 0;
                    case 'avg_vol_sell_1m':
                        return parseFloat(data.avg_VOLCOIN_sell_1MENIT) || 0;

                    // Overall 24h
                    case 'activity_dur_24h':
                        return parseFloat(data.sum_overall_buy) || 0;
                    case 'vol_dur_24h':
                        return parseFloat(data.percent_sum_VOL_overall_buy) || 0;

                    // Sum Durability
                    case 'sum_min_1_buy':
                        return parseFloat(data.sum_minute1_buy) || 0;
                    case 'sum_min_5_buy':
                        return parseFloat(data.sum_minute_5_buy) || 0;
                    case 'sum_min_10_buy':
                        return parseFloat(data.sum_minute_10_buy) || 0;
                    case 'sum_min_15_buy':
                        return parseFloat(data.sum_minute_15_buy) || 0;
                    case 'sum_min_20_buy':
                        return parseFloat(data.sum_minute_20_buy) || 0;
                    case 'sum_min_30_buy':
                        return parseFloat(data.sum_minute_30_buy) || 0;
                    case 'sum_min_60_buy':
                        return parseFloat(data.sum_minute_60_buy) || 0;
                    case 'sum_min_120_buy':
                        return parseFloat(data.sum_minute_120_buy) || 0;
                    case 'sum_overall_buy':
                        return parseFloat(data.sum_overall_buy) || 0;

                    // Volume Durability
                    case 'vol_dur_1m':
                        return parseFloat(data.percent_sum_VOL_minute1_buy) || 0;
                    case 'vol_dur_5m':
                        return parseFloat(data.percent_sum_VOL_minute_5_buy) || 0;
                    case 'vol_dur_10m':
                        return parseFloat(data.percent_sum_VOL_minute_10_buy) || 0;
                    case 'vol_dur_15m':
                        return parseFloat(data.percent_sum_VOL_minute_15_buy) || 0;
                    case 'vol_dur_20m':
                        return parseFloat(data.percent_sum_VOL_minute_20_buy) || 0;
                    case 'vol_dur_30m':
                        return parseFloat(data.percent_sum_VOL_minute_30_buy) || 0;
                    case 'vol_dur_60m':
                        return parseFloat(data.percent_sum_VOL_minute_60_buy) || 0;
                    case 'vol_dur_120m':
                        return parseFloat(data.percent_sum_VOL_minute_120_buy) || 0;
                    case 'vol_dur_overall':
                        return parseFloat(data.percent_sum_VOL_overall_buy) || 0;

                    // Change Variations
                    case 'change_1min_4':
                    case 'change_5min_20':
                    case 'change_10sec_1':
                    case 'change_10min_2':
                    case 'change_10sec_2':
                    case 'change_15min_2':
                    case 'change_1min_5':
                    case 'change_1jam_18':
                    case 'change_20min_2':
                    case 'change_2jam_10':
                    case 'change_30min_1':
                    case 'change_5min_25':
                        // prefer explicit backend fields if available
                        const direct = (function(){
                            const map = {
                                'change_1min_4':'percent_change_1Min_4','change_5min_20':'percent_change_5Min_20','change_10sec_1':'percent_change_10Second_1','change_10min_2':'percent_change_10Min_2','change_10sec_2':'percent_change_10Second_2','change_15min_2':'percent_change_15Min_2','change_1min_5':'percent_change_1Min_5','change_1jam_18':'percent_change_1jam_18','change_20min_2':'percent_change_20Min_2','change_2jam_10':'percent_change_2jam_10','change_30min_1':'percent_change_30Min_1','change_5min_25':'percent_change_5Min_25'
                            };
                            const key = map[criteria];
                            if (key && (data[key] !== undefined && data[key] !== null)) return parseFloat(data[key]) || 0;
                            // try lowercase variants
                            if (key) {
                                const lk = key.toLowerCase();
                                if (data[lk] !== undefined && data[lk] !== null) return parseFloat(data[lk]) || 0;
                            }
                            return null;
                        })();
                        if (direct !== null && direct !== undefined) return direct;
                        // fallback: compute from history; try to infer lookback from the criteria name
                        const ms = parseLookbackMs(criteria);
                        const pct = computeHistoryPercentChange(data, ms || undefined);
                        return Number(pct) || 0;

                    // Update Times (note: per-volume update_time fields are not used as a sorting/reference metric)
                    case 'update_activity':
                        return parseFloat(data.update_time_FREQ) || 0;
                    case 'update_sum':
                        return parseFloat(data.sum_update_time) || 0;
                    case 'update_general':
                        return parseFloat(data.update_time) || 0;

                    // Total Volumes
                    case 'total_vol_fiat':
                        // legacy option: prefer coin-only total instead of fiat
                        return parseFloat(data.total_vol) || 0;
                    case 'total_vol':
                        return parseFloat(data.total_vol) || 0;

                    // Delay
                    case 'delay_ms':
                        return parseFloat(data.delay_ms_aggrade) || 0;

                    default:
                        return parseFloat(data.percent_sum_VOL_minute_120_buy) || 0;
                }
            }

            // Convert coinDataMap to an array for sorting
            const sortedCoins = Object.entries(coinDataMap)
                .filter(([coinKey, data]) => {
                    // Filter coins based on the filter input
                    return !filterText || coinKey.toLowerCase().includes(filterText);
                })
                .sort(([coinKeyA, dataA], [coinKeyB, dataB]) => {
                    // get raw sort values
                    let valueA = getSortValue(dataA, sortBy);
                    let valueB = getSortValue(dataB, sortBy);
                    // coerce to numbers; handle non-numeric gracefully
                    const nA = (valueA === null || valueA === undefined) ? NaN : Number(valueA);
                    const nB = (valueB === null || valueB === undefined) ? NaN : Number(valueB);
                    const a = isFinite(nA) ? nA : 0;
                    const b = isFinite(nB) ? nB : 0;

                    // primary comparison: numeric
                    let diff = 0;
                    if (sortOrder === 'asc') diff = a - b; else diff = b - a;

                    if (diff !== 0 && isFinite(diff)) return diff;
                    // tie-breaker: deterministic coin name order (ascending)
                    const nameCmp = coinKeyA.localeCompare(coinKeyB);
                    return nameCmp;
                });

            // Loop through sorted and filtered data
            for (const [coinKey, data] of sortedCoins) {
                if (rowCount >= rowLimit) break; // Stop if row limit is reached

                const coin = coinKey;
                const price = (data.last || 0).toFixed(4);
                const change = data.percent_change || 0;
                const volDur = getNumeric(data, 'percent_sum_VOL_minute_120_buy', 'percent_vol_buy_120min');
                const volBuy = getNumeric(data, 'count_VOL_minute_120_buy', 'vol_buy_2JAM', 'vol_buy_120MENIT');
                const volSell = getNumeric(data, 'count_VOL_minute_120_sell', 'vol_sell_2JAM', 'vol_sell_120MENIT');

                // Volume 24h data (support multiple field names)
                const volBuy24h = getNumeric(data, 'count_VOL_minute_1440_buy', 'vol_buy_24JAM', 'vol_buy_24jam', 'vol_buy_24h', 'vol_buy_24H');
                const volSell24h = getNumeric(data, 'count_VOL_minute_1440_sell', 'vol_sell_24JAM', 'vol_sell_24jam', 'vol_sell_24h', 'vol_sell_24H');

                // Additional data for multiple timeframes
                // activity counts removed upstream; use volume fields below

                const volBuy1m = getNumeric(data, 'count_VOL_minute1_buy', 'vol_buy_1MENIT', 'vol_buy_1menit', 'vol_buy_1m', 'vol_buy_1min');
                const volSell1m = getNumeric(data, 'count_VOL_minute1_sell', 'vol_sell_1MENIT', 'vol_sell_1menit', 'vol_sell_1m', 'vol_sell_1min');
                const volBuy5m = getNumeric(data, 'count_VOL_minute_5_buy', 'vol_buy_5MENIT', 'vol_buy_5menit', 'vol_buy_5m', 'vol_buy_5min');
                const volSell5m = getNumeric(data, 'count_VOL_minute_5_sell', 'vol_sell_5MENIT', 'vol_sell_5menit', 'vol_sell_5m', 'vol_sell_5min');
                const volBuy10m = getNumeric(data, 'count_VOL_minute_10_buy', 'vol_buy_10MENIT', 'vol_buy_10menit', 'vol_buy_10m', 'vol_buy_10min');
                const volSell10m = getNumeric(data, 'count_VOL_minute_10_sell', 'vol_sell_10MENIT', 'vol_sell_10menit', 'vol_sell_10m', 'vol_sell_10min');
                const volBuy15m = getNumeric(data, 'count_VOL_minute_15_buy', 'vol_buy_15MENIT', 'vol_buy_15m');
                const volSell15m = getNumeric(data, 'count_VOL_minute_15_sell', 'vol_sell_15MENIT', 'vol_sell_15m');
                const volBuy20m = getNumeric(data, 'count_VOL_minute_20_buy', 'vol_buy_20MENIT', 'vol_buy_20m');
                const volSell20m = getNumeric(data, 'count_VOL_minute_20_sell', 'vol_sell_20MENIT', 'vol_sell_20m');
                const volBuy30m = getNumeric(data, 'count_VOL_minute_30_buy', 'vol_buy_30MENIT', 'vol_buy_30m');
                const volSell30m = getNumeric(data, 'count_VOL_minute_30_sell', 'vol_sell_30MENIT', 'vol_sell_30m');
                const volBuy60m = getNumeric(data, 'count_VOL_minute_60_buy', 'vol_buy_1JAM', 'vol_buy_60MENIT', 'vol_buy_60menit', 'vol_buy_60m');
                const volSell60m = getNumeric(data, 'count_VOL_minute_60_sell', 'vol_sell_1JAM', 'vol_sell_60MENIT', 'vol_sell_60menit', 'vol_sell_60m');
                const volBuy2h = getNumeric(data, 'count_VOL_minute_120_buy', 'vol_buy_2JAM', 'vol_buy_120MENIT', 'vol_buy_2jam');
                const volSell2h = getNumeric(data, 'count_VOL_minute_120_sell', 'vol_sell_2JAM', 'vol_sell_120MENIT', 'vol_sell_2jam');

                // Populate Vol Ratio tab row for this coin (if the tab exists)
                try {
                    if (volRatioBody) {
                        const vr = volRatioBody.insertRow();
                        vr.dataset.coin = coin;

                        // Small helper: normalize various numeric formats (remove commas, percent signs)
                        const normalize = (v) => {
                            if (v === undefined || v === null) return 0;
                            if (typeof v === 'number') return v;
                            try {
                                const s = String(v).replace(/[^0-9eE+\-.]/g, '');
                                const n = parseFloat(s);
                                return Number.isFinite(n) ? n : 0;
                            } catch (e) { return 0; }
                        };

                        // Robust ratio formatter: uses normalized numbers and a fallback to analytics fields
                        const fmtRatio = (buyRaw, sellRaw, buyFallback, sellFallback) => {
                            const buy = normalize(buyRaw || buyFallback);
                            const sell = normalize(sellRaw || sellFallback);
                            if (sell > 0) return Math.round((buy / sell) * 100) + '%';
                            if (buy > 0) return 'âˆ';
                            return '0%';
                        };

                        vr.insertCell(0).textContent = coin;
                        vr.insertCell(1).textContent = fmtRatio(volBuy1m, volSell1m, getNumeric(data,'count_VOL_minute1_buy'), getNumeric(data,'count_VOL_minute1_sell'));
                        vr.insertCell(2).textContent = fmtRatio(volBuy5m, volSell5m, getNumeric(data,'count_VOL_minute_5_buy'), getNumeric(data,'count_VOL_minute_5_sell'));
                        vr.insertCell(3).textContent = fmtRatio(volBuy10m, volSell10m, getNumeric(data,'count_VOL_minute_10_buy', 'vol_buy_10MENIT', 'vol_buy_10m'), getNumeric(data,'count_VOL_minute_10_sell', 'vol_sell_10MENIT', 'vol_sell_10m'));

                        vr.insertCell(4).textContent = fmtRatio(volBuy15m, volSell15m, volBuy15m, volSell15m);

                        vr.insertCell(5).textContent = fmtRatio(volBuy20m, volSell20m, volBuy20m, volSell20m);

                        vr.insertCell(6).textContent = fmtRatio(volBuy30m, volSell30m, volBuy30m, volSell30m);

                        vr.insertCell(7).textContent = fmtRatio(volBuy60m, volSell60m, getNumeric(data,'count_VOL_minute_60_buy','vol_buy_1JAM','vol_buy_60MENIT'), getNumeric(data,'count_VOL_minute_60_sell','vol_sell_1JAM','vol_sell_60MENIT'));

                        // For 2h and 24h use precomputed values (already cover multiple aliases) with analytics fallback
                        vr.insertCell(8).textContent = fmtRatio(volBuy2h, volSell2h, (data._analytics && data._analytics.volBuy2h), (data._analytics && data._analytics.volSell2h));
                        vr.insertCell(9).textContent = fmtRatio(volBuy24h, volSell24h, (data._analytics && data._analytics.volBuy24h), (data._analytics && data._analytics.volSell24h));

                        // Last Change %: parse percent strings robustly, else use history-based computation
                        const parsePercent = (v) => {
                            if (v === undefined || v === null) return null;
                            if (typeof v === 'number') return v;
                            const s = String(v).trim();
                            // remove trailing % if present
                            const cleaned = s.replace(/%/g,'');
                            const n = parseFloat(cleaned.replace(/[^0-9eE+\-.]/g,''));
                            return Number.isFinite(n) ? n : null;
                        };

                        let lastChangeVal = null;
                        try {
                            if (data._history && Array.isArray(data._history) && data._history.length >= 2) {
                                const len = data._history.length;
                                const latest = data._history[len - 1];
                                const prev = data._history[len - 2];
                                const p0 = normalize(prev && (prev.price ?? prev.last));
                                const p1 = normalize(latest && (latest.price ?? latest.last));
                                if (p0 > 0 && p1 > 0) lastChangeVal = ((p1 - p0) / p0) * 100;
                            }
                        } catch (e) { lastChangeVal = null; }
                        if (lastChangeVal === null) lastChangeVal = parsePercent(data.percent_change);
                        if (lastChangeVal === null) {
                            lastChangeVal = parsePercent(data.percent_change_24h) ?? parsePercent(data.percent_change_1h) ?? parsePercent(data.percent_change_60m) ?? 0;
                        }

                        const lcCell = vr.insertCell(10);
                        lcCell.textContent = (Number.isFinite(lastChangeVal) ? Number(lastChangeVal.toFixed(2)) : 0) + '%';
                        lcCell.className = lastChangeVal > 0 ? 'text-success' : lastChangeVal < 0 ? 'text-danger' : 'text-muted';
                    }
                } catch (e) { console.warn('volRatio row insert failed for', coin, e); }

                // Detect spikes: compare volume vs average for multiple timeframes
                try {
                    const spikeThreshold = 2.0; // spike when vol >= spikeThreshold * avg
                    const timeframes = [
                        {label: '1m', volKeys: ['count_VOL_minute1_buy','vol_buy_1MENIT','vol_buy_1min'], avgKeys: ['avg_VOLCOIN_buy_1MENIT','avg_VOLCOIN_buy_1MENIT']},
                        {label: '5m', volKeys: ['count_VOL_minute_5_buy','vol_buy_5MENIT','vol_buy_5min'], avgKeys: ['avg_VOLCOIN_buy_5MENIT']},
                        {label: '10m', volKeys: ['count_VOL_minute_10_buy','vol_buy_10MENIT','vol_buy_10min'], avgKeys: ['avg_VOLCOIN_buy_10MENIT']},
                        {label: '15m', volKeys: ['vol_buy_15MENIT'], avgKeys: ['avg_VOLCOIN_buy_15MENIT']},
                        {label: '20m', volKeys: ['vol_buy_20MENIT'], avgKeys: ['avg_VOLCOIN_buy_20MENIT']},
                        {label: '30m', volKeys: ['vol_buy_30MENIT'], avgKeys: ['avg_VOLCOIN_buy_30MENIT']},
                        {label: '60m', volKeys: ['count_VOL_minute_60_buy','vol_buy_1JAM','vol_buy_60MENIT'], avgKeys: ['avg_VOLCOIN_buy_1JAM']},
                        {label: '120m', volKeys: ['count_VOL_minute_120_buy','vol_buy_2JAM','vol_buy_120MENIT'], avgKeys: ['avg_VOLCOIN_buy_2JAM']},
                        {label: '24h', volKeys: ['count_VOL_minute_1440_buy','vol_buy_24JAM','vol_buy_24h'], avgKeys: ['avg_VOLCOIN_buy_24JAM']}
                    ];

                    for (const tf of timeframes) {
                        const vol = getNumeric(data, ...tf.volKeys);
                        const avg = getNumeric(data, ...tf.avgKeys);
                        if (avg > 0 && vol / avg >= spikeThreshold) {
                            spikeRows.push({ coin, timeframe: tf.label, vol, avg, ratio: vol / avg, update_time: data.update_time || data.update_time_VOLCOIN || 0 });
                        }
                    }
                } catch (e) { console.error('Spike detection error', e); }

                // Helper function for durability color coding (divided into 3 equal parts)
                function getDurabilityClass(value) {
                    if (value >= 67) return 'durability-excellent';  // Top 1/3: 67-100
                    if (value >= 34) return 'durability-good';       // Middle 1/3: 34-66
                    return 'durability-poor';                       // Bottom 1/3: 0-33
                }

                // Summary row (compact) â€” make the entire row clickable for insights
                let row = summaryBody.insertRow();
                row.classList.add('summary-row');
                row.style.cursor = 'pointer';
                // store coin on the row for delegated clicks
                row.dataset.coin = coin;
                // Clicking anywhere on the row will open insights for the coin (delegation also set up)
                row.onclick = () => showInsightTab(coin, data);
                const coinCell = row.insertCell(0);
                coinCell.textContent = coin;
                coinCell.className = 'text-primary';
                coinCell.title = 'Click for insights';
                row.insertCell(1).textContent = price;
                let cell = row.insertCell(2);
                cell.textContent = change + '%';
                cell.className = change > 0 ? 'text-success fw-bold' : change < 0 ? 'text-danger fw-bold' : 'text-muted';

                // Price Position (scaled 0-100 from low to high)
                const currentPrice = parseFloat(data.last) || 0;
                const highPrice = parseFloat(data.high) || currentPrice;
                const lowPrice = parseFloat(data.low) || currentPrice;
                const priceRange = highPrice - lowPrice;
                const pricePosition = priceRange > 0 ? Math.round(((currentPrice - lowPrice) / priceRange) * 100) : 50;
                cell = row.insertCell(3);
                cell.textContent = pricePosition + '%';
                cell.className = getDurabilityClass(pricePosition);

                // Recommendation Algorithm
                const selectedTf = (typeof recTimeframeSelect !== 'undefined' && recTimeframeSelect && recTimeframeSelect.value) ? recTimeframeSelect.value : '120m';
                const recommendation = calculateRecommendation(data, pricePosition, selectedTf, true);
                cell = row.insertCell(4);
                cell.textContent = recommendation && recommendation.recommendation ? `${recommendation.recommendation} (${recommendation.confidence || 0}%)` : 'HOLD';
                cell.className = recommendation && recommendation.className ? recommendation.className : 'recommendation-hold';

                // Risk column
                cell = row.insertCell(5);
                const riskScore = data.risk_score || (data._analytics && data._analytics.riskScore) || 0;
                cell.textContent = riskScore + '%';
                cell.className = riskScore >= 67 ? 'text-danger fw-bold' : riskScore >= 40 ? 'text-warning fw-bold' : 'text-success fw-bold';

                // Vol Buy/Sell 2h and durability
                // Primary source: percent_sum_VOL_minute_120_buy (if provided by backend)
                let volDur2h = getNumeric(data, 'percent_sum_VOL_minute_120_buy', 'percent_vol_buy_120min', 'percent_vol_buy_2jam');

                // Fallback: if backend doesn't provide percent_sum_VOL_minute_120_buy, compute it from volBuy2h/(volBuy2h+volSell2h)
                if ((!volDur2h || volDur2h === 0) && (volBuy2h || volSell2h)) {
                    const total2h = (volBuy2h || 0) + (volSell2h || 0);
                    volDur2h = total2h > 0 ? Math.round(((volBuy2h || 0) / total2h) * 100) : 0;
                }

                // Volume Ratio % (Buy vs Sell in 2h, scaled to 100)
                const volumeRatio2h = volSell2h > 0 ? (volBuy2h / volSell2h) * 100 : (volBuy2h > 0 ? 999 : 0);
                cell = row.insertCell(6);
                cell.textContent = Math.round(volumeRatio2h) + '%';
                cell.className = volumeRatio2h > 200 ? 'text-success fw-bold' : volumeRatio2h < 50 ? 'text-danger fw-bold' : 'text-warning fw-bold';

                row.insertCell(7).textContent = volBuy2h;
                row.insertCell(8).textContent = volSell2h;

                cell = row.insertCell(9);
                cell.textContent = (isNaN(volDur2h) ? 0 : volDur2h) + '%';
                cell.className = getDurabilityClass(volDur2h);

                // 24h volumes
                row.insertCell(10).textContent = volBuy24h;
                row.insertCell(11).textContent = volSell24h;

                // Update time (handle seconds or milliseconds)
                let ts = data.update_time || data.update_time_VOLCOIN || 0;
                // if ts looks like milliseconds (>= 1e12) use directly, if seconds (<1e12) multiply
                if (ts && ts < 1e12) ts = ts * 1000;
                row.insertCell(12).textContent = ts ? new Date(ts).toLocaleString() : '-';

                // Add per-timeframe recommendations to Recs tab (respect row limit)
                if (recsBody) {
                        // maximum number of rec rows requested by the user (rowLimit comes from `limitInput`)
                        const requestedRecsLimit = isFinite(rowLimit) ? rowLimit : Infinity;
                        // keep previous safety cap on coins processed for performance
                        const perfCoinCap = 50;
                        if (rowCount < perfCoinCap && !doneRecs) {
                            const tfs = [
                                {label: '1m', lookback: 60},
                                {label: '5m', lookback: 5*60},
                                {label: '10m', lookback: 10*60},
                                {label: '30m', lookback: 30*60},
                                {label: '60m', lookback: 60*60},
                                {label: '120m', lookback: 120*60},
                                {label: '24h', lookback: 24*60*60}
                            ];

                            const selectedTf = (typeof recTimeframeSelect !== 'undefined' && recTimeframeSelect && recTimeframeSelect.value) ? recTimeframeSelect.value : 'All';

                            // If 'All' is selected, aggregate scores across timeframes and emit one row per coin
                            if (selectedTf === 'All') {
                                if (recsRowCount < requestedRecsLimit) {
                                    const priceNow = parseFloat(data.last) || 0;
                                    const pricePosTf = pricePosition;
                                    // Aggregate weighted score by confidence
                                    let sumWeighted = 0, sumWeight = 0;
                                    for (const tf of tfs) {
                                        const recTf = calculateRecommendation(data, pricePosTf, tf.label, false);
                                        const w = (recTf.confidence || 0) / 100;
                                        sumWeighted += (recTf.score || 0) * w;
                                        sumWeight += w;
                                    }
                                    const aggScore = sumWeight ? (sumWeighted / sumWeight) : 0;
                                    const aggConfidence = Math.round(Math.min(100, Math.abs(aggScore) * 100));
                                    let aggRecLabel = 'HOLD';
                                    if (aggScore >= RECOMMENDATION_THRESHOLD) aggRecLabel = 'BUY';
                                    else if (aggScore <= -RECOMMENDATION_THRESHOLD) aggRecLabel = 'SELL';

                                    // sensitivity from UI (default 1)
                                    const sens = (confSensitivity && Number(confSensitivity.value)) || 1;
                                    const tpMin = tpMinInput ? Math.max(0, Number(tpMinInput.value) || 2) / 100 : 0.02;
                                    const tpMax = tpMaxInput ? Math.max(tpMin, Number(tpMaxInput.value) || 0.10) / 100 : 0.10;
                                    const slMax = slMaxInput ? Math.max(0, Number(slMaxInput.value) || 5) / 100 : 0.05;
                                    let rangeFactor = Math.min(tpMax, tpMin + (aggConfidence/100) * (tpMax - tpMin) * sens);
                                    if (useAtrRecs && useAtrRecs.checked && data._history) {
                                        const atr = computeATR(data._history, 14);
                                        if (atr > 0 && priceNow > 0) {
                                            const atrPct = (atr / priceNow) * sens;
                                            rangeFactor = Math.min(tpMax, Math.max(tpMin, atrPct));
                                        }
                                    }
                                    let tp = '-', sl = '-';
                                    if (priceNow > 0 && aggRecLabel === 'BUY') {
                                        tp = (priceNow * (1 + rangeFactor)).toFixed(4);
                                        sl = (priceNow * (1 - Math.min(slMax, Math.max(0.005, rangeFactor/2)))).toFixed(4);
                                    } else if (priceNow > 0 && aggRecLabel === 'SELL') {
                                        tp = (priceNow * (1 - rangeFactor)).toFixed(4);
                                        sl = (priceNow * (1 + Math.min(slMax, Math.max(0.005, rangeFactor/2)))).toFixed(4);
                                    }
                                    const r = recsBody.insertRow();
                                    r.insertCell(0).textContent = coin;
                                    r.insertCell(1).textContent = 'All';
                                    r.insertCell(2).textContent = `${aggRecLabel}`;
                                    r.insertCell(3).textContent = `${aggConfidence || 0}%`;
                                    r.insertCell(4).textContent = priceNow || '-';
                                    r.insertCell(5).textContent = tp;
                                    r.insertCell(6).textContent = sl;
                                    recsRowCount++;
                                }
                            } else {
                                // Single timeframe selected: show per-coin recommendation for that timeframe
                                if (recsRowCount < requestedRecsLimit) {
                                    const priceNow = parseFloat(data.last) || 0;
                                    const pricePosTf = pricePosition;
                                    const recTf = calculateRecommendation(data, pricePosTf, selectedTf, true);
                                    const conf = (recTf.confidence || 0) / 100; // 0..1

                                    // sensitivity from UI (default 1)
                                    const sens = (confSensitivity && Number(confSensitivity.value)) || 1;

                                    // base TP/SL from UI
                                    const tpMin = tpMinInput ? Math.max(0, Number(tpMinInput.value) || 2) / 100 : 0.02;
                                    const tpMax = tpMaxInput ? Math.max(tpMin, Number(tpMaxInput.value) || 0.10) / 100 : 0.10;
                                    const slMax = slMaxInput ? Math.max(0, Number(slMaxInput.value) || 5) / 100 : 0.05;

                                    // determine rangeFactor either ATR-based or confidence-based
                                    let rangeFactor = Math.min(tpMax, tpMin + conf * (tpMax - tpMin) * sens);
                                    if (useAtrRecs && useAtrRecs.checked && data._history) {
                                        const atr = computeATR(data._history, 14);
                                        if (atr > 0 && priceNow > 0) {
                                            const atrPct = (atr / priceNow) * sens;
                                            rangeFactor = Math.min(tpMax, Math.max(tpMin, atrPct));
                                        }
                                    }

                                    let tp = '-';
                                    let sl = '-';
                                    if (priceNow > 0 && recTf.recommendation === 'BUY') {
                                        tp = (priceNow * (1 + rangeFactor)).toFixed(4);
                                        sl = (priceNow * (1 - Math.min(slMax, Math.max(0.005, rangeFactor/2)))).toFixed(4);
                                    } else if (priceNow > 0 && recTf.recommendation === 'SELL') {
                                        tp = (priceNow * (1 - rangeFactor)).toFixed(4);
                                        sl = (priceNow * (1 + Math.min(slMax, Math.max(0.005, rangeFactor/2)))).toFixed(4);
                                    }
                                    const r = recsBody.insertRow();
                                    r.insertCell(0).textContent = coin;
                                    r.insertCell(1).textContent = selectedTf;
                                    r.insertCell(2).textContent = `${recTf.recommendation}`;
                                    r.insertCell(3).textContent = `${recTf.confidence || 0}%`;
                                    r.insertCell(4).textContent = priceNow || '-';
                                    r.insertCell(5).textContent = tp;
                                    r.insertCell(6).textContent = sl;
                                    recsRowCount++;
                                }
                            }
                        }
                }

                // Continue to render other tables even if recs reached the requested limit
                // Activity rows removed â€” feed provides only volume-based metrics now

                // Vol row (multiple timeframes)
                row = volBody.insertRow();
                row.insertCell(0).textContent = coin;
                row.insertCell(1).textContent = volBuy1m;
                row.insertCell(2).textContent = volSell1m;
                row.insertCell(3).textContent = volBuy5m;
                row.insertCell(4).textContent = volSell5m;
                row.insertCell(5).textContent = volBuy10m;
                row.insertCell(6).textContent = volSell10m;
                // 15m
                row.insertCell(7).textContent = getNumeric(data, 'count_VOL_minute_15_buy', 'vol_buy_15MENIT', 'vol_buy_15m');
                row.insertCell(8).textContent = getNumeric(data, 'count_VOL_minute_15_sell', 'vol_sell_15MENIT', 'vol_sell_15m');
                // 20m
                row.insertCell(9).textContent = getNumeric(data, 'count_VOL_minute_20_buy', 'vol_buy_20MENIT', 'vol_buy_20m');
                row.insertCell(10).textContent = getNumeric(data, 'count_VOL_minute_20_sell', 'vol_sell_20MENIT', 'vol_sell_20m');
                // 30m
                row.insertCell(11).textContent = getNumeric(data, 'count_VOL_minute_30_buy', 'vol_buy_30MENIT', 'vol_buy_30m');
                row.insertCell(12).textContent = getNumeric(data, 'count_VOL_minute_30_sell', 'vol_sell_30MENIT', 'vol_sell_30m');
                // 60m
                row.insertCell(13).textContent = volBuy60m;
                row.insertCell(14).textContent = volSell60m;
                // 120m (2h)
                row.insertCell(15).textContent = volBuy;
                row.insertCell(16).textContent = volSell;

                // Volume Ratio % for 2h timeframe
                const volRatio2h = volSell > 0 ? (volBuy / volSell) * 100 : (volBuy > 0 ? 999 : 0);
                cell = row.insertCell(17);
                cell.textContent = Math.round(volRatio2h) + '%';
                cell.className = volRatio2h > 200 ? 'text-success fw-bold' : volRatio2h < 50 ? 'text-danger fw-bold' : 'text-warning fw-bold';

                // 24h volumes
                row.insertCell(18).textContent = volBuy24h;
                row.insertCell(19).textContent = volSell24h;
                row.insertCell(20).textContent = (volBuy24h || 0) + (volSell24h || 0);

                // Vol Durability row (1m/5m/10m/15m/20m/30m/1h/24h)
                try {
                    const vdr = volDurBody.insertRow();
                    vdr.insertCell(0).textContent = coin;
                    // price change cell
                    try {
                        const pct = (data && (data.percent_change !== undefined)) ? Number(data.percent_change) : (data && data.last && data.previous ? ((Number(data.last)-Number(data.previous))/Number(data.previous))*100 : NaN);
                        const ccell = vdr.insertCell(1);
                        if (!isNaN(pct)) {
                            ccell.textContent = (Math.round(pct*100)/100) + '%';
                            ccell.className = pct > 0 ? 'text-success fw-bold' : (pct < 0 ? 'text-danger fw-bold' : '');
                        } else {
                            ccell.textContent = '-';
                        }
                    } catch (e) {
                        try { vdr.insertCell(1).textContent = '-'; } catch(e){}
                    }
                    // helper to get percent durability or compute from buy/(buy+sell)
                    function getDurPct(pctKey, buyKeys, sellKeys) {
                        let p = getNumeric(data, pctKey);
                        if (p && p > 0) return Math.round(p);
                        const b = getNumeric(data, ...buyKeys);
                        const s = getNumeric(data, ...sellKeys);
                        const t = (b || 0) + (s || 0);
                        return t > 0 ? Math.round((b / t) * 100) : 0;
                    }

                    const d1 = getDurPct('percent_sum_VOL_minute1_buy', ['count_VOL_minute1_buy','vol_buy_1MENIT','vol_buy_1m'], ['count_VOL_minute1_sell','vol_sell_1MENIT','vol_sell_1m']);
                    const d5 = getDurPct('percent_sum_VOL_minute_5_buy', ['count_VOL_minute_5_buy','vol_buy_5MENIT','vol_buy_5m'], ['count_VOL_minute_5_sell','vol_sell_5MENIT','vol_sell_5m']);
                    const d10 = getDurPct('percent_sum_VOL_minute_10_buy', ['count_VOL_minute_10_buy','vol_buy_10MENIT','vol_buy_10m'], ['count_VOL_minute_10_sell','vol_sell_10MENIT','vol_sell_10m']);
                    const d15 = getDurPct('percent_sum_VOL_minute_15_buy', ['count_VOL_minute_15_buy','vol_buy_15MENIT','vol_buy_15m'], ['count_VOL_minute_15_sell','vol_sell_15MENIT','vol_sell_15m']);
                    const d20 = getDurPct('percent_sum_VOL_minute_20_buy', ['count_VOL_minute_20_buy','vol_buy_20MENIT','vol_buy_20m'], ['count_VOL_minute_20_sell','vol_sell_20MENIT','vol_sell_20m']);
                    const d30 = getDurPct('percent_sum_VOL_minute_30_buy', ['count_VOL_minute_30_buy','vol_buy_30MENIT','vol_buy_30m'], ['count_VOL_minute_30_sell','vol_sell_30MENIT','vol_sell_30m']);
                    const d60 = getDurPct('percent_sum_VOL_minute_60_buy', ['count_VOL_minute_60_buy','vol_buy_1JAM','vol_buy_60MENIT'], ['count_VOL_minute_60_sell','vol_sell_1JAM','vol_sell_60MENIT']);
                    const d24 = getDurPct('percent_sum_VOL_overall_buy', ['count_VOL_minute_1440_buy','vol_buy_24JAM','vol_buy_24h'], ['count_VOL_minute_1440_sell','vol_sell_24JAM','vol_sell_24h']);

                    const cells = [d1,d5,d10,d15,d20,d30,d60,d24];
                    for (const cval of cells) {
                        const c = vdr.insertCell(-1);
                        c.textContent = (isNaN(cval) ? 0 : cval) + '%';
                        c.className = getDurabilityClass(cval);
                    }
                } catch (e) { console.warn('volDur row error', e); }

                rowCount++;
            }

            // Render spike table sorted by ratio (descending)
            if (spikeBody) {
                // sort and optionally limit to rowLimit
                spikeRows.sort((a,b) => b.ratio - a.ratio);
                const maxSpikes = isFinite(rowLimit) ? rowLimit : spikeRows.length;
                const showRows = spikeRows.slice(0, maxSpikes);
                for (const s of showRows) {
                    const r = spikeBody.insertRow();
                    r.insertCell(0).textContent = s.coin;
                    r.insertCell(1).textContent = s.timeframe;
                    r.insertCell(2).textContent = s.vol;
                    r.insertCell(3).textContent = s.avg;
                    const cell = r.insertCell(4);
                    cell.textContent = (s.ratio).toFixed(2) + 'x';
                    cell.className = s.ratio >= 4 ? 'text-success fw-bold' : s.ratio >= 2 ? 'text-warning fw-bold' : '';
                    const ts = s.update_time && s.update_time < 1e12 ? s.update_time * 1000 : s.update_time;
                    r.insertCell(5).textContent = ts ? new Date(ts).toLocaleString() : '-';
                }
            }
            try { window._lastSpikeRows = spikeRows.slice(0, 50); } catch (e) { /* ignore */ }
            // update Info tab (keeps runtime info current)
            try { renderInfoTab(); } catch (e) { console.warn('renderInfoTab failed', e); }
            maybeRenderHeavyTab('signalLab', renderSignalLab, { interval: 1500 });
            maybeRenderHeavyTab('backtest', renderBacktestTab, { interval: 6000 });
            maybeRenderHeavyTab('risk', renderRiskMonitorTab, { interval: 3000 });
            maybeRenderHeavyTab('events', renderEventWatchTab, { interval: 2500, requireActive: false });
        }

        // Populate the Info tab with runtime state and quick actions
        function renderInfoTab() {
            try {
                const container = document.getElementById('info');
                if (!container) return;
                // Prefer a dedicated runtime container so we don't overwrite static Info content
                let pane = document.getElementById('infoRuntime');
                if (!pane) {
                    pane = document.createElement('div');
                    pane.id = 'infoRuntime';
                    pane.className = 'mb-3';
                    container.insertBefore(pane, container.firstElementChild);
                }

                // compute some runtime values
                const fmtNum = (val, digits = 2) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? n.toFixed(digits) : '-';
                };
                const fmtPct = (val, digits = 1) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? `${n.toFixed(digits)}%` : '-';
                };
                const fmtInt = (val) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? Math.round(n).toLocaleString() : '-';
                };

                const wsStateMap = {0:'CONNECTING',1:'OPEN',2:'CLOSING',3:'CLOSED'};
                const wsState = (typeof ws !== 'undefined' && ws && ws.readyState !== undefined) ? wsStateMap[ws.readyState] || ws.readyState : 'N/A';
                const coinCount = Object.keys(coinDataMap || {}).length;
                // Activity fields intentionally removed upstream â€” dashboard uses volume-only metrics
                const alerts = loadAlertsFromStore();
                const persistStore = (function(){ try { return JSON.parse(localStorage.getItem(PERSIST_KEY) || '{}'); } catch(e){ return {}; } })();
                const persistedCoins = Object.keys(persistStore || {}).length;
                const lsKeys = Object.keys(localStorage).filter(k => k.toString().toLowerCase().indexOf('okx_calc')===0 || k.toString().toLowerCase().includes('okx'));

                // find last update across coins
                let lastTs = 0;
                for (const c of Object.values(coinDataMap)) {
                    try {
                        if (c && c._history && c._history.length) {
                            const t = c._history[c._history.length - 1].ts || 0;
                            if (t > lastTs) lastTs = t;
                        }
                    } catch(e){}
                }

                // prepare last raw JSON and summary info
                const lastRaw = (window._lastWsRaw) ? window._lastWsRaw : null;
                const lastCoin = (window._lastReceivedCoin) ? window._lastReceivedCoin : null;
                const lastData = lastRaw || (lastCoin ? (coinDataMap[lastCoin] || null) : null);
                const analytics = (lastData && lastData._analytics) ? lastData._analytics : {};
                const history = (lastData && Array.isArray(lastData._history)) ? lastData._history.slice(-120) : [];
                const priceNow = Number(lastData && lastData.last) || 0;
                const priceHigh = Number(lastData && lastData.high) || priceNow;
                const priceLow = Number(lastData && lastData.low) || priceNow;
                const priceRange = priceHigh - priceLow;
                const pricePosition = priceRange > 0 ? ((priceNow - priceLow) / priceRange) * 100 : 50;

                const histPrices = history.map(h => Number(h.price) || 0).filter(v => v > 0);
                const meanStd = (arr) => {
                    if (!arr.length) return { mean: 0, std: 0 };
                    const mean = arr.reduce((sum, v) => sum + v, 0) / arr.length;
                    const variance = arr.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / arr.length;
                    return { mean, std: Math.sqrt(variance) };
                };
                const priceStats = meanStd(histPrices);
                const priceZScore = (histPrices.length >= 6 && priceStats.std > 0 && priceNow)
                    ? (priceNow - priceStats.mean) / priceStats.std
                    : 0;

                const calcHistoryReturn = (ms) => {
                    if (!history.length || !ms) return 0;
                    const cutoff = Date.now() - ms;
                    let older = history[0];
                    for (let i = history.length - 1; i >= 0; i--) {
                        if ((history[i].ts || 0) <= cutoff) {
                            older = history[i];
                            break;
                        }
                    }
                    const olderPrice = Number(older && older.price) || 0;
                    const latestPrice = Number(history[history.length - 1] && history[history.length - 1].price) || 0;
                    if (!olderPrice || !latestPrice) return 0;
                    return ((latestPrice - olderPrice) / olderPrice) * 100;
                };

                const obvProxy = (() => {
                    if (history.length < 2) return 0;
                    let obv = 0;
                    for (let i = 1; i < history.length; i++) {
                        const prevPrice = Number(history[i - 1].price) || 0;
                        const currPrice = Number(history[i].price) || 0;
                        if (!prevPrice || !currPrice) continue;
                        const buyVol = Number(history[i].volBuy2h) || 0;
                        const sellVol = Number(history[i].volSell2h) || 0;
                        const delta = Math.abs(buyVol - sellVol);
                        if (currPrice > prevPrice) obv += delta;
                        else if (currPrice < prevPrice) obv -= delta;
                    }
                    return obv;
                })();

                const vwapValue = (() => {
                    if (!history.length) return 0;
                    let num = 0;
                    let den = 0;
                    for (const point of history) {
                        const price = Number(point.price) || 0;
                        const vol = (Number(point.volBuy2h) || 0) + (Number(point.volSell2h) || 0);
                        if (price && vol) {
                            num += price * vol;
                            den += vol;
                        }
                    }
                    return den > 0 ? num / den : 0;
                })();

                const priceVsVwapPct = (vwapValue > 0 && priceNow > 0) ? ((priceNow - vwapValue) / vwapValue) * 100 : 0;
                const atr14 = (history.length && typeof computeATR === 'function') ? computeATR(history, 14) : 0;
                const freqBuy = Number(analytics.freqBuy2h) || 0;
                const freqSell = Number(analytics.freqSell2h) || 0;
                const freqTotal = freqBuy + freqSell;
                const freqRatio = freqTotal > 0 ? (freqBuy / freqTotal) * 100 : 0;
                const freqMomentum = Number((Number(analytics.zScoreFreqBuy2h) || 0) - (Number(analytics.zScoreFreqSell2h) || 0));
                const volMomentum = Number((Number(analytics.zScoreBuy2h) || 0) - (Number(analytics.zScoreSell2h) || 0));
                const change5m = calcHistoryReturn(5 * 60 * 1000);
                const change15m = calcHistoryReturn(15 * 60 * 1000);
                const sharpInsights = (analytics.sharpInsights && analytics.sharpInsights.length) ? analytics.sharpInsights.join(' â€¢ ') : 'No sharp anomalies detected';
                const persistenceVol = analytics.persistenceBuy3 !== undefined ? analytics.persistenceBuy3 : '-';
                const persistenceFreq = analytics.persistenceFreqBuy3 !== undefined ? analytics.persistenceFreqBuy3 : '-';
                let recSnapshot = null;
                try {
                    const tf = (typeof recTimeframeSelect !== 'undefined' && recTimeframeSelect && recTimeframeSelect.value) ? recTimeframeSelect.value : '120m';
                    recSnapshot = calculateRecommendation && lastData ? calculateRecommendation(lastData, Math.round(pricePosition), tf, false) : null;
                } catch (e) { recSnapshot = null; }

                const analyticsSnapshot = {
                    pricePosition: fmtPct(pricePosition, 1),
                    priceZ: fmtNum(priceZScore, 2),
                    vwap: fmtNum(vwapValue, 4),
                    priceVsVwap: fmtPct(priceVsVwapPct, 2),
                    obv: fmtInt(obvProxy),
                    atr: fmtNum(atr14, 6),
                    freqRatio: fmtPct(freqRatio, 1),
                    freqVsAvg: fmtPct(analytics.freqBuy_vs_avg_percent, 1),
                    volVsAvg: fmtPct(analytics.volBuy_vs_avg_percent, 1),
                    freqMomentum: fmtNum(freqMomentum, 2),
                    volMomentum: fmtNum(volMomentum, 2),
                    change5m: fmtPct(change5m, 2),
                    change15m: fmtPct(change15m, 2)
                };

                let rawStr = '-';
                try { rawStr = lastRaw ? JSON.stringify(lastRaw, null, 2) : '-'; } catch(e){ rawStr = '-'; }
                const lastUpdateHuman = (lastData && (lastData.update_time || lastData.update_time_VOLCOIN)) ? (new Date(Number(lastData.update_time) || Number(lastData.update_time_VOLCOIN) || Date.now()).toLocaleString()) : '-';

                const html = `
                    <div class="card bg-dark text-light mb-2 p-3">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <h5 class="mb-1">Runtime</h5>
                                <div class="small text-muted">WebSocket: <strong>${wsState}</strong></div>
                                <div class="small text-muted">Coins tracked: <strong>${coinCount}</strong></div>
                                <div class="small text-muted">Last update: <strong>${lastTs?new Date(lastTs).toLocaleString():'-'}</strong></div>
                            </div>
                            <div class="text-end">
                                <div class="small text-muted">Persist enabled: <strong>${persistHistoryEnabled ? 'Yes' : 'No'}</strong></div>
                                <div class="small text-muted">Persisted coins: <strong>${persistedCoins}</strong></div>
                                <div class="small text-muted">Stored alerts: <strong>${alerts.length}</strong></div>
                            </div>
                        </div>
                        <hr/>
                        <div class="row">
                            <div class="col-md-6">
                                <h6 class="mb-1">Last Raw JSON</h6>
                                <pre id="lastRawJson" style="max-height:220px;overflow:auto;background:rgba(0,0,0,0.6);padding:10px;border-radius:6px;color:#cbd5e1;">${rawStr}</pre>
                            </div>
                            <div class="col-md-6">
                                <h6 class="mb-1">Last Summary</h6>
                                <div class="small text-muted">Coin: <strong>${lastData && lastData.coin ? lastData.coin : '-'}</strong></div>
                                <div class="small text-muted">Last Price: <strong>${lastData && (lastData.last !== undefined) ? lastData.last : '-'}</strong></div>
                                <div class="small text-muted">Change %: <strong>${lastData && (lastData.percent_change !== undefined) ? lastData.percent_change : '-'}</strong></div>
                                <div class="small text-muted">Total Vol: <strong>${lastData && (lastData.total_vol !== undefined) ? lastData.total_vol : '-'}</strong></div>
                                <div class="small text-muted">Update Time: <strong>${lastUpdateHuman}</strong></div>
                                <hr class="my-2"/>
                                <h6 class="mb-1">Analytics Snapshot</h6>
                                <div class="small text-muted row g-2">
                                    <div class="col-sm-6">
                                        <div>Price Position: <strong>${analyticsSnapshot.pricePosition}</strong></div>
                                        <div>Price Z-Score: <strong>${analyticsSnapshot.priceZ}</strong></div>
                                        <div>VWAP (hist): <strong>${analyticsSnapshot.vwap}</strong></div>
                                        <div>Price vs VWAP: <strong>${analyticsSnapshot.priceVsVwap}</strong></div>
                                        <div>ATR(14): <strong>${analyticsSnapshot.atr}</strong></div>
                                        <div>OBV Proxy: <strong>${analyticsSnapshot.obv}</strong></div>
                                        <div>Delta Price 5m: <strong>${analyticsSnapshot.change5m}</strong></div>
                                        <div>Delta Price 15m: <strong>${analyticsSnapshot.change15m}</strong></div>
                                    </div>
                                    <div class="col-sm-6">
                                        <div>Vol Buy (2h): <strong>${fmtInt(analytics.volBuy2h)}</strong></div>
                                        <div>Vol Sell (2h): <strong>${fmtInt(analytics.volSell2h)}</strong></div>
                                        <div>Vol Ratio (2h): <strong>${fmtPct(analytics.volRatioBuySell_percent, 1)}</strong></div>
                                        <div>Vol vs Avg (Buy): <strong>${analyticsSnapshot.volVsAvg}</strong></div>
                                        <div>Freq Ratio (2h): <strong>${analyticsSnapshot.freqRatio}</strong></div>
                                        <div>Freq vs Avg (Buy): <strong>${analyticsSnapshot.freqVsAvg}</strong></div>
                                        <div>Vol Momentum (z): <strong>${analyticsSnapshot.volMomentum}</strong></div>
                                        <div>Freq Momentum (z): <strong>${analyticsSnapshot.freqMomentum}</strong></div>
                                    </div>
                                </div>
                                <div class="small text-muted mt-2">
                                    <div>Persistence (Vol): <strong>${persistenceVol}</strong></div>
                                    <div>Persistence (Freq): <strong>${persistenceFreq}</strong></div>
                                    <div>Risk Score: <strong>${analytics && analytics.riskScore !== undefined ? analytics.riskScore + '%' : '-'}</strong></div>
                                    <div>Sharp Insights: <strong>${sharpInsights}</strong></div>
                                    <div>Recommendation: <strong>${recSnapshot ? recSnapshot.recommendation : 'HOLD'}${recSnapshot ? ` (${recSnapshot.confidence}% | ${fmtNum(recSnapshot.score,2)})` : ''}</strong></div>
                                </div>
                            </div>
                        </div>
                        <hr/>
                        <div class="d-flex gap-2 mt-2">
                            <button id="exportPersistBtn" class="btn btn-sm btn-outline-primary">Export Persisted History</button>
                            <button id="clearPersistBtn" class="btn btn-sm btn-outline-danger">Clear Persisted History</button>
                            <button id="exportLSBtn" class="btn btn-sm btn-outline-secondary">Export okx_calc LocalStorage</button>
                            <button id="clearLSBtn" class="btn btn-sm btn-outline-dark">Clear okx_calc LocalStorage</button>
                            <button id="openRunJsonBtn" class="btn btn-sm btn-outline-success">Run JSON (Paste)</button>
                        </div>
                        <div class="mt-2 small text-muted">LocalStorage keys: <strong>${lsKeys.length}</strong> (showing keys starting with 'okx_calc' or containing 'okx')</div>
                    </div>`;

                pane.innerHTML = html;

                // No activity tab logic required â€” using volume-only metrics

                // wire buttons
                const expBtn = document.getElementById('exportPersistBtn');
                const clrBtn = document.getElementById('clearPersistBtn');
                const expLS = document.getElementById('exportLSBtn');
                const clrLS = document.getElementById('clearLSBtn');

                if (expBtn) expBtn.onclick = function() {
                    try {
                        const blob = new Blob([JSON.stringify(persistStore || {}, null, 2)], {type:'application/json'});
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a'); a.href = url; a.download = `persisted-history-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
                    } catch (e) { console.warn('exportPersist failed', e); showAlertBanner('Export failed', 'Could not export persisted history', 'danger', 4000); }
                };

                if (clrBtn) clrBtn.onclick = function() {
                    try {
                        if (!confirm('Clear all persisted history? This will remove per-coin stored histories.')) return;
                        localStorage.setItem(PERSIST_KEY, JSON.stringify({}));
                        showAlertBanner('Persist cleared', 'Persisted history removed', 'info', 3000);
                    } catch (e) { console.warn('clearPersist failed', e); showAlertBanner('Clear failed','Could not clear persisted history','danger',4000); }
                };

                if (expLS) expLS.onclick = function() {
                    try {
                        const dump = {};
                        for (const k of lsKeys) dump[k] = localStorage.getItem(k);
                        const blob = new Blob([JSON.stringify(dump, null, 2)], {type:'application/json'});
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a'); a.href = url; a.download = `okx-calc-localstorage-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
                    } catch (e) { console.warn('exportLS failed', e); showAlertBanner('Export failed','Could not export localStorage','danger',4000); }
                };

                if (clrLS) clrLS.onclick = function() {
                    try {
                        if (!confirm('Clear all okx_calc related LocalStorage keys?')) return;
                        for (const k of lsKeys) localStorage.removeItem(k);
                        showAlertBanner('LocalStorage cleared','Removed okx_calc keys', 'info', 3000);
                        renderAlertsList();
                    } catch (e) { console.warn('clearLS failed', e); showAlertBanner('Clear failed','Could not clear localStorage','danger',4000); }
                };

                // Wire Run JSON (Paste) button to open test modal
                try {
                    const runBtn = document.getElementById('openRunJsonBtn');
                    if (runBtn) {
                        runBtn.addEventListener('click', () => {
                            try {
                                ensureTestJsonModal();
                                const modalEl = document.getElementById('testJsonModal');
                                const bs = new bootstrap.Modal(modalEl);
                                // wire run action each time to ensure fresh handler
                                setTimeout(() => {
                                    const run = document.getElementById('testJsonRunBtn');
                                    const ta = document.getElementById('testJsonTextarea');
                                    const err = document.getElementById('testJsonError');
                                    if (run && ta) {
                                        run.onclick = () => {
                                            try {
                                                const txt = ta.value || '';
                                                if (!txt) { if (err) { err.style.display='block'; err.textContent='Please paste JSON payload.'; } return; }
                                                let obj = null;
                                                try { obj = JSON.parse(txt); } catch(parseErr) { if (err) { err.style.display='block'; err.textContent='Invalid JSON: '+parseErr.message; } return; }
                                                // hide error
                                                if (err) { err.style.display='none'; err.textContent=''; }
                                                // simulate WebSocket event
                                                if (typeof onWsMessage === 'function') {
                                                    onWsMessage({ data: JSON.stringify(obj) });
                                                    bs.hide();
                                                } else {
                                                    if (err) { err.style.display='block'; err.textContent='Handler not available.'; }
                                                }
                                            } catch(e) { console.warn('testJson run failed', e); }
                                        };
                                    }
                                }, 10);
                                bs.show();
                            } catch(e) { console.warn('openRunJson failed', e); }
                        });
                    }
                } catch(e) { console.warn('wiring openRunJsonBtn failed', e); }

            } catch (e) { console.warn('renderInfoTab error', e); }
        }

        function renderSignalLab() {
            try {
                const pane = document.getElementById('signalLabPane');
                const coinSelect = document.getElementById('signalLabCoinSelect');
                const tfSelect = document.getElementById('signalLabTfSelect');
                const statusEl = document.getElementById('signalLabStatus');
                if (!pane || !coinSelect || !tfSelect) return;
                const coins = Object.keys(coinDataMap || {});
                if (!coins.length) {
                    coinSelect.innerHTML = '';
                    pane.innerHTML = '<p class="mb-0 text-muted">Waiting for dataâ€¦</p>';
                    if (statusEl) statusEl.textContent = '-';
                    return;
                }
                if (!coinSelect.dataset.bound) {
                    coinSelect.addEventListener('change', () => {
                        window._signalLabCoin = coinSelect.value;
                        renderSignalLab();
                    });
                    coinSelect.dataset.bound = '1';
                }
                if (!tfSelect.dataset.bound) {
                    tfSelect.addEventListener('change', () => renderSignalLab());
                    tfSelect.dataset.bound = '1';
                }
                const prevCoin = window._signalLabCoin || coinSelect.value || coins[0];
                const currentCoin = coins.includes(prevCoin) ? prevCoin : coins[0];
                coinSelect.innerHTML = coins.map(c => `<option value="${c}" ${c === currentCoin ? 'selected' : ''}>${c}</option>`).join('');
                window._signalLabCoin = currentCoin;
                const data = coinDataMap[currentCoin];
                if (!data) {
                    pane.innerHTML = '<p class="mb-0 text-muted">No data for selected coin.</p>';
                    if (statusEl) statusEl.textContent = '-';
                    return;
                }
                const timeframe = tfSelect.value || '120m';
                const analytics = data._analytics || {};
                const price = Number(data.last) || 0;
                const high = Number(data.high) || price;
                const low = Number(data.low) || price;
                const range = high - low;
                const pricePos = range > 0 ? Math.round(((price - low) / range) * 100) : 50;
                const rec = (typeof calculateRecommendation === 'function') ? calculateRecommendation(data, pricePos, timeframe, false) : null;
                const factors = (rec && rec.factors) ? rec.factors : {};
                const fmtNum = (val, digits = 2) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? n.toFixed(digits) : '-';
                };
                const fmtPct = (val, digits = 1) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? `${n.toFixed(digits)}%` : '-';
                };
                const volRatio = analytics.volRatioBuySell_percent !== undefined ? fmtPct(analytics.volRatioBuySell_percent, 1) : '-';
                const durability = analytics.volDurability2h_percent !== undefined ? fmtPct(analytics.volDurability2h_percent, 1) : '-';
                const freqRatio = (() => {
                    const b = Number(analytics.freqBuy2h) || 0;
                    const s = Number(analytics.freqSell2h) || 0;
                    const tot = b + s;
                    return tot > 0 ? fmtPct((b / tot) * 100, 1) : '-';
                })();
                const insights = (analytics.sharpInsights && analytics.sharpInsights.length)
                    ? analytics.sharpInsights.join(' â€¢ ')
                    : 'No sharp anomalies';
                const factorDefs = [
                    { key: 'priceBias', label: 'Price Bias', desc: 'Location within recent range' },
                    { key: 'volDurNorm', label: 'Vol Durability (2h)', desc: 'Buy % dominance in 2h' },
                    { key: 'vol24Norm', label: 'Vol Durability (24h)', desc: 'Daily buy % tilt' },
                    { key: 'zImbalance', label: 'Volume Z-Imbalance', desc: 'z-score buy minus sell' },
                    { key: 'freqImbalance', label: 'Frequency Imbalance', desc: 'Trade count skew' },
                    { key: 'persistenceNorm', label: 'Persistence', desc: 'Streak of buy pressure' },
                    { key: 'divergenceNorm', label: 'Divergence', desc: 'Flow vs price tension' },
                    { key: 'riskPenalty', label: 'Risk Penalty', desc: 'Liquidity/volatility drag', invert: true }
                ];
                const factorHtml = factorDefs.map(def => {
                    const raw = Number(factors[def.key]);
                    const val = Number.isFinite(raw) ? raw : 0;
                    const pct = Math.max(0, Math.min(100, Math.round((val + 1) * 50)));
                    const good = def.invert ? val <= 0 : val >= 0;
                    const barClass = good ? 'bg-success' : 'bg-danger';
                    return `
                        <div class="mb-2">
                            <div class="d-flex justify-content-between">
                                <span>${def.label}</span>
                                <span>${fmtNum(val, 2)}</span>
                            </div>
                            <div class="progress" style="height:6px;">
                                <div class="progress-bar ${barClass}" role="progressbar" style="width:${pct}%"></div>
                            </div>
                            <div class="text-muted">${def.desc}</div>
                        </div>`;
                }).join('');
                if (statusEl) {
                    const text = rec ? `${rec.recommendation} (${rec.confidence || 0}%)` : 'HOLD';
                    statusEl.textContent = text;
                    statusEl.className = `fw-bold ${rec && rec.className ? rec.className : 'text-info'}`;
                }
                pane.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h5 class="mb-0">${currentCoin}</h5>
                            <small class="text-muted">${timeframe} Â· Price ${price ? price.toFixed(4) : '-'}</small>
                        </div>
                        <div class="text-end">
                            <div class="fw-bold ${rec && rec.className ? rec.className : 'text-info'}">${rec ? rec.recommendation : 'HOLD'} (${rec ? rec.confidence : 0}%)</div>
                            <small class="text-muted">Score ${rec && Number.isFinite(rec.score) ? rec.score.toFixed(2) : '0.00'}</small>
                        </div>
                    </div>
                    <div class="row mt-3">
                        <div class="col-lg-7">
                            ${factorHtml || '<p class="text-muted">No factor data yet.</p>'}
                        </div>
                        <div class="col-lg-5">
                            <h6 class="small text-muted">Flow Snapshot</h6>
                            <ul class="list-unstyled small mb-2">
                                <li>Price Position: <strong>${fmtPct(pricePos, 1)}</strong></li>
                                <li>Vol Ratio (2h): <strong>${volRatio}</strong></li>
                                <li>Vol Durability (2h): <strong>${durability}</strong></li>
                                <li>Freq Ratio (2h): <strong>${freqRatio}</strong></li>
                                <li>Risk Score: <strong>${analytics && analytics.riskScore !== undefined ? analytics.riskScore + '%' : '-'}</strong></li>
                            </ul>
                            <div class="small text-muted">Insights: <strong>${insights}</strong></div>
                        </div>
                    </div>`;
            } catch (e) { console.warn('renderSignalLab error', e); }
        }

        function renderBacktestTab() {
            try {
                const pane = document.getElementById('backtestPane');
                const coinSelect = document.getElementById('backtestCoinSelect');
                const sampleEl = document.getElementById('backtestSampleCount');
                if (!pane || !coinSelect) return;
                const coins = Object.keys(coinDataMap || {});
                if (!coins.length) {
                    coinSelect.innerHTML = '';
                    pane.innerHTML = '<p class="mb-0 text-muted">Waiting for recommendationsâ€¦</p>';
                    if (sampleEl) sampleEl.textContent = '0';
                    return;
                }
                if (!coinSelect.dataset.bound) {
                    coinSelect.addEventListener('change', () => {
                        window._backtestCoin = coinSelect.value;
                        renderBacktestTab();
                    });
                    coinSelect.dataset.bound = '1';
                }
                const prevCoin = window._backtestCoin || coinSelect.value || coins[0];
                const currentCoin = coins.includes(prevCoin) ? prevCoin : coins[0];
                coinSelect.innerHTML = coins.map(c => `<option value="${c}" ${c === currentCoin ? 'selected' : ''}>${c}</option>`).join('');
                window._backtestCoin = currentCoin;
                const data = coinDataMap[currentCoin];
                const history = (data && Array.isArray(data._history)) ? data._history.slice().sort((a,b) => (a.ts||0) - (b.ts||0)) : [];
                const log = (data && data._analytics && Array.isArray(data._analytics.recommendationLog)) ? data._analytics.recommendationLog.slice(-200) : [];
                if (sampleEl) sampleEl.textContent = String(log.length || 0);
                if (!log.length || history.length < 2) {
                    pane.innerHTML = '<p class="mb-0 text-muted">Need more recommendations and history to run backtests.</p>';
                    return;
                }
                const fmtPct = (val, digits = 2) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? `${n.toFixed(digits)}%` : '-';
                };
                const fmtNum = (val, digits = 2) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? n.toFixed(digits) : '-';
                };
                const findPriceAt = (targetTs) => {
                    for (let i = 0; i < history.length; i++) {
                        const point = history[i];
                        if ((point.ts || 0) >= targetTs) return Number(point.price) || 0;
                    }
                    return Number(history.length ? history[history.length - 1].price : 0) || 0;
                };
                const horizons = [
                    { label: '5m', ms: 5 * 60 * 1000 },
                    { label: '15m', ms: 15 * 60 * 1000 },
                    { label: '60m', ms: 60 * 60 * 1000 },
                    { label: '120m', ms: 120 * 60 * 1000 }
                ];
                const computeStats = (horizon) => {
                    const details = [];
                    let wins = 0;
                    const deltas = [];
                    for (const entry of log) {
                        if (!entry || entry.recommendation === 'HOLD') continue;
                        const entryPrice = Number(entry.price) || findPriceAt(entry.ts);
                        if (!entryPrice) continue;
                        const futurePrice = findPriceAt(entry.ts + horizon.ms);
                        if (!futurePrice) continue;
                        const rawChange = ((futurePrice - entryPrice) / entryPrice) * 100;
                        const directional = entry.recommendation === 'SELL' ? -rawChange : rawChange;
                        deltas.push(directional);
                        if (directional >= 0) wins++;
                        details.push({ ts: entry.ts, recommendation: entry.recommendation, confidence: entry.confidence, score: entry.score, outcome: directional, horizonMs: horizon.ms });
                    }
                    const avg = deltas.length ? (deltas.reduce((sum, v) => sum + v, 0) / deltas.length) : 0;
                    const sorted = deltas.slice().sort((a, b) => a - b);
                    const median = sorted.length ? sorted[Math.floor(sorted.length / 2)] : 0;
                    const worst = sorted.length ? sorted[0] : 0;
                    const winRate = deltas.length ? (wins / deltas.length) * 100 : 0;
                    return { label: horizon.label, samples: deltas.length, winRate, avg, median, worst, details };
                };
                const stats = horizons.map(computeStats);
                const rows = stats.map(s => `
                    <tr>
                        <td>${s.label}</td>
                        <td>${s.samples}</td>
                        <td>${fmtPct(s.winRate, 1)}</td>
                        <td>${fmtPct(s.avg, 2)}</td>
                        <td>${fmtPct(s.median, 2)}</td>
                        <td>${fmtPct(s.worst, 2)}</td>
                    </tr>`).join('');
                const primaryDetails = stats.length ? stats[0].details.slice(-5).reverse() : [];
                const recentHtml = primaryDetails.length ? primaryDetails.map(item => {
                    const time = item.ts ? new Date(item.ts).toLocaleTimeString() : '-';
                    return `<li class="list-group-item bg-dark text-light border-secondary">
                        <div class="d-flex justify-content-between">
                            <span>${time}</span>
                            <span>${item.recommendation} Â· ${item.confidence || 0}%</span>
                        </div>
                        <div>Outcome after 5m: <strong class="${item.outcome >= 0 ? 'text-success' : 'text-danger'}">${fmtPct(item.outcome, 2)}</strong> (score ${fmtNum(item.score, 2)})</div>
                    </li>`;
                }).join('') : '<li class="list-group-item bg-dark text-light border-secondary">No realized trades yet.</li>';
                pane.innerHTML = `
                    <div class="table-responsive">
                        <table class="table table-dark table-striped table-sm mb-0">
                            <thead>
                                <tr>
                                    <th>Horizon</th>
                                    <th>Samples</th>
                                    <th>Win %</th>
                                    <th>Avg Change</th>
                                    <th>Median</th>
                                    <th>Worst</th>
                                </tr>
                            </thead>
                            <tbody>${rows}</tbody>
                        </table>
                    </div>
                    <div class="mt-3">
                        <h6 class="text-info">Recent Outcomes (5m horizon)</h6>
                        <ul class="list-group list-group-flush">${recentHtml}</ul>
                    </div>`;
            } catch (e) { console.warn('renderBacktestTab error', e); }
        }

        function renderRiskMonitorTab() {
            try {
                const pane = document.getElementById('riskPane');
                const coinSelect = document.getElementById('riskCoinSelect');
                const lookbackSelect = document.getElementById('riskLookbackSelect');
                if (!pane || !coinSelect || !lookbackSelect) return;
                const coins = Object.keys(coinDataMap || {});
                if (!coins.length) {
                    coinSelect.innerHTML = '';
                    pane.innerHTML = '<p class="mb-0 text-muted">Waiting for dataâ€¦</p>';
                    return;
                }
                if (!coinSelect.dataset.bound) {
                    coinSelect.addEventListener('change', () => {
                        window._riskCoin = coinSelect.value;
                        renderRiskMonitorTab();
                    });
                    coinSelect.dataset.bound = '1';
                }
                if (!lookbackSelect.dataset.bound) {
                    lookbackSelect.addEventListener('change', () => renderRiskMonitorTab());
                    lookbackSelect.dataset.bound = '1';
                }
                const prevCoin = window._riskCoin || coinSelect.value || coins[0];
                const currentCoin = coins.includes(prevCoin) ? prevCoin : coins[0];
                coinSelect.innerHTML = coins.map(c => `<option value="${c}" ${c === currentCoin ? 'selected' : ''}>${c}</option>`).join('');
                window._riskCoin = currentCoin;
                const lookback = Number(lookbackSelect.value) || 100;
                const data = coinDataMap[currentCoin];
                const analytics = data && data._analytics ? data._analytics : {};
                const history = (data && Array.isArray(data._history)) ? data._history.slice(-Math.max(20, lookback)) : [];
                if (history.length < 2) {
                    pane.innerHTML = '<p class="mb-0 text-muted">Not enough history to compute risk metrics.</p>';
                    return;
                }
                const fmtNum = (val, digits = 4) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? n.toFixed(digits) : '-';
                };
                const fmtPct = (val, digits = 2) => {
                    const n = Number(val);
                    return Number.isFinite(n) ? `${n.toFixed(digits)}%` : '-';
                };
                const prices = history.map(h => Number(h.price) || 0).filter(v => v > 0);
                if (prices.length < 2) {
                    pane.innerHTML = '<p class="mb-0 text-muted">Price history missing.</p>';
                    return;
                }
                const returns = [];
                for (let i = 1; i < prices.length; i++) {
                    const prev = prices[i - 1];
                    const curr = prices[i];
                    if (prev) returns.push(((curr - prev) / prev) * 100);
                }
                const meanReturn = returns.length ? returns.reduce((s, v) => s + v, 0) / returns.length : 0;
                const variance = returns.length ? returns.reduce((s, v) => s + Math.pow(v - meanReturn, 2), 0) / returns.length : 0;
                const returnStd = Math.sqrt(Math.max(variance, 0));
                const realizedVol = returnStd * Math.sqrt(60);
                const sortedReturns = returns.slice().sort((a, b) => a - b);
                const tailIdx = sortedReturns.length ? Math.max(0, Math.floor(sortedReturns.length * 0.05) - 1) : 0;
                const tailRisk = sortedReturns.length ? sortedReturns[tailIdx] : 0;
                let peak = prices[0];
                let maxDD = 0;
                for (const price of prices) {
                    if (price > peak) peak = price;
                    if (peak > 0) {
                        const dd = ((price - peak) / peak) * 100;
                        if (dd < maxDD) maxDD = dd;
                    }
                }
                const drawdown = Math.abs(maxDD);
                const atr = typeof computeATR === 'function' ? computeATR(history, 14) : 0;
                const riskScore = Number(data.risk_score || analytics.riskScore) || 0;
                const stressIndex = Math.round(Math.min(100, (Math.abs(tailRisk) * 1.5) + (realizedVol * 0.8) + (riskScore * 0.5)));
                const freqBuy = Number(analytics.freqBuy2h) || 0;
                const freqSell = Number(analytics.freqSell2h) || 0;
                const freqTotal = freqBuy + freqSell;
                const freqRatio = freqTotal > 0 ? (freqBuy / freqTotal) * 100 : 0;
                const volBuy = Number(analytics.volBuy2h) || 0;
                const volSell = Number(analytics.volSell2h) || 0;
                const volRatio = volSell > 0 ? (volBuy / volSell) * 100 : (volBuy > 0 ? 999 : 0);
                const stressClass = stressIndex >= 70 ? 'alert-danger' : stressIndex >= 50 ? 'alert-warning' : 'alert-success';
                pane.innerHTML = `
                    <div class="row g-3">
                        <div class="col-md-6">
                            <h6 class="text-info">Volatility & Drawdown</h6>
                            <ul class="list-unstyled small mb-0">
                                <li>ATR (14): <strong>${fmtNum(atr, 6)}</strong></li>
                                <li>Realized Vol (hourly): <strong>${fmtPct(realizedVol, 2)}</strong></li>
                                <li>Tail Risk (5th pct): <strong>${fmtPct(tailRisk, 2)}</strong></li>
                                <li>Max Drawdown: <strong>${fmtPct(drawdown, 2)}</strong></li>
                                <li>Mean Return: <strong>${fmtPct(meanReturn, 2)}</strong></li>
                            </ul>
                        </div>
                        <div class="col-md-6">
                            <h6 class="text-info">Flow & Liquidity</h6>
                            <ul class="list-unstyled small mb-0">
                                <li>Vol Ratio (2h): <strong>${fmtPct(volRatio, 1)}</strong></li>
                                <li>Freq Ratio (2h): <strong>${fmtPct(freqRatio, 1)}</strong></li>
                                <li>Risk Score: <strong>${riskScore}%</strong></li>
                                <li>Liquidity Proxy: <strong>${fmtNum(analytics.liquidity_avg_trade_value || 0, 2)}</strong></li>
                                <li>Sharp Insights: <strong>${(analytics.sharpInsights && analytics.sharpInsights[0]) || 'None'}</strong></li>
                            </ul>
                            <div class="${stressClass} mt-2 py-2 px-3 small">
                                Market Stress Index: <strong>${stressIndex}</strong>/100
                            </div>
                        </div>
                    </div>`;
            } catch (e) { console.warn('renderRiskMonitorTab error', e); }
        }

        function renderEventWatchTab() {
            try {
                const pane = document.getElementById('eventPane');
                if (!pane) return;
                const alerts = typeof loadAlertsFromStore === 'function' ? loadAlertsFromStore().slice(-10).reverse() : [];
                const events = (window._eventWatchBuffer || []).slice(-10).reverse();
                const spikes = (window._lastSpikeRows || []).slice(0, 10);
                if (!alerts.length && !events.length && !spikes.length) {
                    pane.innerHTML = '<p class="mb-0 text-muted">No events captured yet.</p>';
                    return;
                }
                const renderItems = (items, formatter, emptyText) => {
                    if (!items.length) return `<div class="text-muted">${emptyText}</div>`;
                    return items.map(formatter).join('');
                };
                const eventHtml = renderItems(events, (e) => {
                    const time = e.ts ? new Date(e.ts).toLocaleTimeString() : '-';
                    const msg = (e.messages || []).join(' â€¢ ');
                    return `<div class="list-group-item bg-dark text-light border-secondary mb-2">
                        <div class="d-flex justify-content-between"><strong>${e.coin || '-'}</strong><small class="text-muted">${time}</small></div>
                        <div>${msg || e.type || ''}</div>
                    </div>`;
                }, 'No sharp-insight events.');
                const alertHtml = renderItems(alerts, (a) => {
                    const time = a.ts ? new Date(a.ts).toLocaleTimeString() : '-';
                    return `<div class="list-group-item bg-dark text-light border-secondary mb-2">
                        <div class="d-flex justify-content-between"><strong>${a.coin || '-'}</strong><small class="text-muted">${time}</small></div>
                        <div>${a.message || ''}</div>
                    </div>`;
                }, 'No stored alerts.');
                const spikeHtml = renderItems(spikes, (s) => {
                    return `<div class="list-group-item bg-dark text-light border-secondary mb-2">
                        <div class="d-flex justify-content-between"><strong>${s.coin}</strong><small class="text-muted">${s.timeframe}</small></div>
                        <div>Volume spike ${s.ratio.toFixed(2)}x</div>
                    </div>`;
                }, 'No spike events.');
                pane.innerHTML = `
                    <div class="row g-3">
                        <div class="col-md-4">
                            <h6 class="text-info">Sharp Insights</h6>
                            <div class="small">${eventHtml}</div>
                        </div>
                        <div class="col-md-4">
                            <h6 class="text-info">Stored Alerts</h6>
                            <div class="small">${alertHtml}</div>
                        </div>
                        <div class="col-md-4">
                            <h6 class="text-info">Recent Spikes</h6>
                            <div class="small">${spikeHtml}</div>
                        </div>
                    </div>`;
            } catch (e) { console.warn('renderEventWatchTab error', e); }
        }

        const TAB_RENDER_INTERVALS = {
            signalLab: 1500,
            backtest: 6000,
            risk: 3000,
            events: 2500
        };
        const lastTabRenderAt = {};

        function maybeRenderHeavyTab(tabId, renderer, options = {}) {
            try {
                const pane = document.getElementById(tabId);
                if (!pane || typeof renderer !== 'function') return;
                const requireActive = options.requireActive !== false;
                const isActive = pane.classList.contains('active') || pane.classList.contains('show');
                if (requireActive && !isActive) return;
                const interval = options.interval || TAB_RENDER_INTERVALS[tabId] || 1500;
                const now = Date.now();
                const last = lastTabRenderAt[tabId] || 0;
                if (now - last < interval) return;
                lastTabRenderAt[tabId] = now;
                renderer();
            } catch (e) { console.warn('maybeRenderHeavyTab error', e); }
        }

        // Open info tab and scroll to Vol Ratio section
        function showVolRatioInfo() {
            try {
                const tab = document.getElementById('info-tab');
                if (tab) tab.click();
                setTimeout(() => {
                    const el = document.getElementById('volRatioSection');
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // highlight briefly
                        const orig = el.style.boxShadow;
                        el.style.boxShadow = '0 0 12px rgba(255,235,59,0.9)';
                        setTimeout(() => { el.style.boxShadow = orig; }, 1600);
                    }
                }, 180);
            } catch (e) { console.warn('showVolRatioInfo failed', e); }
        }
    </script>

    <!-- Hidden Alerts Modal -->
    <div class="modal fade" id="hiddenAlertsModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header">
                    <h5 class="modal-title">Hidden Alerts</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="hiddenAlertsModalBody" style="max-height:60vh;overflow:auto;"></div>
                <div class="modal-footer">
                    <button type="button" id="restoreHiddenAsBanners" class="btn btn-sm btn-outline-primary">Show as banners</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Restore hidden alerts as banners when modal button clicked
        try {
            const restoreBtn = document.getElementById('restoreHiddenAsBanners');
            if (restoreBtn) restoreBtn.addEventListener('click', () => {
                try {
                    const container = document.getElementById('alertBanner');
                    if (!container) return;
                    while (hiddenAlertBuffer && hiddenAlertBuffer.length) {
                        const a = hiddenAlertBuffer.shift();
                        try { showAlertBanner(a.title, a.message, a.type, 8000); } catch(e) { console.warn('restore show failed', e); }
                    }
                    // hide modal
                    try { const bm = bootstrap.Modal.getInstance(document.getElementById('hiddenAlertsModal')); if (bm) bm.hide(); } catch(e){}
                } catch(e) { console.warn('restoreHiddenAsBanners failed', e); }
            });
        } catch(e) { console.warn('wiring restore hidden alerts failed', e); }
    </script>
</body>

</html>


